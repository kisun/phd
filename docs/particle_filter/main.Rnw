\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage{parskip}

<<echo=FALSE,results="hide">>=
opts_chunk$set(fig.width=8,fig.height=5,fig.align="center")
library(mvtnorm)
@ 


\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bs}{\boldsymbol{s}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bfn}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bH}{\boldsymbol{H}}
\newcommand{\bK}{\boldsymbol{K}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bZero}{\boldsymbol{0}}
\newcommand{\dd}[2]{\frac{\partial {#1}}{\partial {#2}}}

\newcommand{\X}{\mathrm{X}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\V}{\mathrm{V}}


\newcommand{\pr}{\mathbb{P}}
\renewcommand{\Pr}[1]{\pr\left(#1\right)}


\newcommand{\km}{_{k-1}}
\newcommand{\kk}{_{k|k}}
\newcommand{\kkm}{_{k|k-1}}
\newcommand{\kmkm}{_{k-1|k-1}}


\title{Particle Filter}
\author{Exploration}
\date{}

\begin{document}
\maketitle


\section{Trajectory Constrained tos ``Road''}


We propose a two-stage algorithm that involves several different aspects:

\begin{itemize}
\item GPS location: this is a vector $\by = \left[p_{\mathrm{lat}}, p_{\mathrm{lon}}\right]^T$; we
  must also take into account GPS error (which is typically known, and can at least be estimated).
  

\item Route information: we know where the bus will be going, which reduced the 2-dimentional
  problem down to 1; we need to switch between $\by$ and $d = $ distance into trip.
\end{itemize}


We will be using the following system model, where, at time $k \in 1,\ldots,K$, 
\begin{itemize}
\item 
  $\bx_k$ is the state $\left[d_k, v_k\right]^T$ (= distance-into-trip and velocity, respectively)
  
\item
  $f_k$ is the (assumed known) system transition function, 
  
\item
  $\bu_k$ are the control variables $\left[t_k, \Delta_k\right]^T$ (= time in seconds and time between
  observations, respectively), and
  
\item
  $\bw_k$ is a zero-mean white noise with known distribution $p(\bw_k)$,
  
\end{itemize}
which leads us to:
\begin{equation}
  \label{eq:state_model1}
  \bx_k = 
  f_k\left(\bx_k, \bu_k\right) + \bw_k.
\end{equation}

The second part is the observation equation, which consists of
\begin{itemize}
\item 
  $\by_k$, the observations (GPS coordinates),

\item 
  $h_k$, the measurement function, and

\item 
  $v_k$, the zero-mean, white system noise (e.g., GPS error, \ldots),
\end{itemize}
which come together to give us
\begin{equation}
  \label{eq:state_model2}
  \by_k = 
  h_k\left(\hat\bx_k\right) + \bv_k.
\end{equation}
In our case, $h_k = h$ will map distance-into-trip values to GPS coordinates.
The reason for converting between distance and GPS is to help overcome potential issues that will
arise for example when routes do a ``loop''.


\subsection{Example 1: Straight Trajectory}

In this first example, the ``route'' will be a straight line, observations will be evenly
distributed (i.e., $\Delta_k = \Delta = 1$ for simplicity), and we will use a simple first order
dynamics equation, where $\bw_k$ is the unknown accelaration,
\begin{equation}
  \label{eq:simple_dynamics}
  \bx_k = A\bx_{k-1} + Gw_k,
\end{equation}
where 
$A =
\begin{bmatrix}
  1 & \Delta \\ 0 & 1
\end{bmatrix}$ and 
$G =
\begin{bmatrix}
  \frac{\Delta^2}{2} \\ \Delta
\end{bmatrix}$.
We can later complicate it.

The next part is the mapping from distance to GPS. We will have a single path (with known bearing $\Psi$), so we
can for now get away with (remembering that $d_k = \bx_{1k}$):
\begin{equation}
  \label{eq:d_to_gps}
  h\left(\hat \bx_k\right) = 
  d_k \begin{bmatrix}
    \sin \Psi \\ \cos \Psi
  \end{bmatrix}
\end{equation}


\subsubsection{Simulation Setup}

The ``route'' will start from the origin and end at $\left(20, 15\right)$,
which gives the bearing $\Psi = \tan^{-1}\left(\frac{20}{15}\right)$. 
We then take observations at times $t \in 1, \ldots, 5$~(s), with a constant speed of 3~ms$^{-1}$ from beginning to
end, and ``GPS error'' of 0.5~(m). Thus, the actual positions and simulated observations are:
<<true_positions>>=
set.seed(345346)
Psi <- atan(20/15)
h <- function(x) x[1] * rbind(sin(Psi), cos(Psi))
t <- 1:5
Xtrue <- rbind(t * 3, 3)
Ytrue <- apply(Xtrue, 2, h)
y <- round(Ytrue + t(rmvnorm(length(t), sigma = diag(c(0.5, 0.5)))), 4)

theplot <- function() {
    plot(y[1, ], y[2, ], pch = 19, xlim = c(0, 20), ylim = c(-2, 15), asp = 1,
         xlab = expression(p[lon]), ylab = expression(p[lat]))
    abline(h = 0, v = 0, lty = 3)
    lines(c(0, 20), c(0, 15), lty = 2)
    points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
}
theplot()
@ 


\subsubsection{Simulation Results}

We need a prior distribution on the initial position, which is infact known exactly, however the
speed is unknown:
\begin{equation}
  \label{eq:prior}
  x_0 \sim \mathcal{N}\left(
    \begin{bmatrix}
      0 \\ v_0
    \end{bmatrix},
    \begin{bmatrix}
      0 & 0 \\
      0 & 5
    \end{bmatrix}
  \right),\quad v_0 = 5.
\end{equation}



<<run_pf>>=
lhood <- function(y, x)
    dmvnorm(y, h(x), diag(c(1, 1)))
pw <- function(n)
    rnorm(n, 0, 0.2)
Delta <- 1
A <- cbind(c(1, 0), c(Delta, 1))
G <- rbind(Delta^2/2, Delta)
fn <- function(x, w)
    structure(A %*% x + G %*% w, .Dimnames = list(c("distance", "speed"), NULL))

N <- 200
x0 <- t(rmvnorm(N, c(0, 5), diag(c(0, 5))))
theplot()

x1hat <- fn(x0, pw(N))
hx1hat <- apply(x1hat, 2, h)
points(hx1hat[1, ], hx1hat[2, ], pch = 3, col = "#00009970")

weights <- apply(x1hat, 2, function(xi) lhood(y[, 1], xi))
qi <- weights / sum(weights)
ii <- sample(N, N, TRUE, qi)
x1 <- x1hat[, ii]

hx1 <- apply(x1, 2, h)
points(hx1[1, ], hx1[2, ], pch = 19, col = "#00990040", cex = 0.5)
points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
@ 


Now for the rest of them \ldots

<<run_pf_loop,fig.width=16,fig.height=10>>=
par(mfrow = c(2, 2))
xx <- x1
M <- length(t)
xxhat.hist <- xx.hist <- array(NA, c(2, N, M))
xxhat.hist[,,1] <- x1hat
xx.hist[,,1] <- x1
for (i in t[-1]) {
    xxhat.hist[,,i] <- xxhat <- fn(xx, pw(N))
    weights <- apply(xxhat, 2, function(xi) lhood(y[, i], xi))
    qi <- weights / sum(weights)
    ii <- sample(N, N, TRUE, qi)
    xx.hist[,,i] <- xx <- xxhat[, ii]
    
    hxxhat <- apply(xxhat, 2, h)
    hxx <- apply(xx, 2, h)
    
    theplot()
    points(hxxhat[1, ], hxxhat[2, ], pch = 3, col = "#00009070")
    points(hxx[1, ], hxx[2, ], pch = 19, col = "#00990040", cex = 0.5)
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, i], Ytrue[2, i], pch = 19, cex = 0.6, col = "red")
}

rowMeans(xx)
@ 

<<dist_speed_plot>>=
plot(NA, xlim = range(xxhat.hist[1,,]), ylim = range(xxhat.hist[2,,]),
     xlab = "Distance (m)", ylab = "Speed (m/s)")
cols <- rainbow(M)
colsa <- rainbow(M, alpha = 0.1)
invisible(
    sapply(t, function(ti) {
               points(xxhat.hist[1,,ti], xxhat.hist[2,,ti], pch = 19, col = colsa[ti])
               points(xx.hist[1,,ti], xx.hist[2,,ti], pch = 19, col = cols[ti], cex = 0.3)
           })
    )

@ 



\subsection{Example 2: A Road with Corners}

We will now construct an artifical road that is made up of several segments. Here's the road:

<<road_segments>>=
px <- c(0, 5, 7, 3, -2, -4)
py <- c(0, 3, 6, 8, 7, 2)
road <- function() {
    plot(px, py, type = "l", lty = 2, xlim = c(0, 10), ylim = c(-5, 10), asp = 1,
         xlab = expression(p[lon]), ylab = expression(p[lat]))
    abline(h = 0, v = 0, lty = 3)
}
road()
@ 

Currently, we are \emph{not} using real GPS coordinates, so we don't yet have to worry about
scaling; therefore, we will use simple Euclidean distances to compute the (cumulative) length of
each line segment.

We then take observations at times $t \in 1,\ldots,5$ (s), of a ``vehicle'' travelling at 3~ms$^{-1}$,
again with a ``GPS error'' of 0.5~(m).

<<road_lengths>>=
shape <- data.frame(lon = px, lat = py,
                    distance = c(0, cumsum(sqrt(diff(px)^2 + diff(py)^2))))
shape$distance
@ 

The problem now is converting from distance to cartesian (GPS). This will involve an algorithm of
two steps:
\begin{enumerate}
\item 
  Find the ``point'', $\br_j$, in the shape set that has the smallest positive difference from the
  ``observed'' distance, $d_k$;

\item 
  Calculate the distance into the segment $\bs_j = \overrightarrow{\br_{j}\br_{j+1}} = \br_{j+1}
  - \br_j$, and the bearing of the segment, to calcualte the GPS position of the observation:
  \begin{equation}
    \label{eq:bearing_calc}
    \Psi_j = 
    \begin{cases}
      \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} >= 0, \\
      360 - \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} < 0.
    \end{cases}
  \end{equation}
  
  \begin{equation}
    \label{eq:converstion_formula}
    h_j\left(\hat\bx_k\right) = d_k 
    \begin{bmatrix}
      \sin \Psi_j \\ \cos \Psi_j
    \end{bmatrix}.
  \end{equation}
  
  The subscripts are: $j$ for the segment identification, each which has its own bearing and length,
  and $k$ for the observations (multiple observations can belong to the same segment---useful for
  reducing computations).
  
\end{enumerate}

For the most part, this can be added to the database;
<<segment_stuff>>=
shape$length <- c(sqrt(diff(px)^2 + diff(py)^2), NA)
theta <- 2 * pi - (atan2(diff(py), diff(px)) - pi / 2)
shape$bearing <- c(theta - 2 * pi * (theta >= 2 * pi), NA)
shape

h <- function(x, shape) {
    if (x[1] <= 0) return(c(0, 0))
    if (x[1] >= max(shape$distance)) return(as.numeric(shape[nrow(shape), 1:2]))
    
    j <- which.min(x[1] > shape$distance) - 1
    sj <- shape[j, ]
    Psi <- sj$bearing
    d <- x[1] - sj$distance
    as.numeric(sj[1:2]) + d * c(sin(Psi), cos(Psi))
}

Ytrue <- apply(Xtrue, 2, h, shape = shape)
y <- round(Ytrue + t(rmvnorm(length(t), sigma = diag(c(0.5, 0.5)))), 4)

theplot2 <- function() {
    road()
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
}
theplot2()
@ 

Other than the above, everything else is basically the same!

<<results_ex2>>=
lhood <- function(y, x, shape)
    dmvnorm(y, h(x, shape), diag(c(1, 1)))

N <- 200
x0 <- t(rmvnorm(N, c(0, 5), diag(c(0, 5))))
theplot2()

x1hat <- fn(x0, pw(N))
hx1hat <- apply(x1hat, 2, h, shape = shape)
points(hx1hat[1, ], hx1hat[2, ], pch = 3, col = "#00009970")

weights <- apply(x1hat, 2, function(xi) lhood(y[, 1], xi, shape))
qi <- weights / sum(weights)
ii <- sample(N, N, TRUE, qi)
x1 <- x1hat[, ii]

hx1 <- apply(x1, 2, h, shape = shape)
points(hx1[1, ], hx1[2, ], pch = 19, col = "#00990040", cex = 0.5)
points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
@ 

That look wonderful! Now for the rest \ldots

<<run_pf_loop2,fig.width=6,fig.height=10,out.width="0.6\\textwidth">>=
par(mfrow = c(4, 1))
xx <- x1
M <- length(t)
xxhat.hist <- xx.hist <- array(NA, c(2, N, M))
xxhat.hist[,,1] <- x1hat
xx.hist[,,1] <- x1
for (i in t[-1]) {
    xxhat.hist[,,i] <- xxhat <- fn(xx, pw(N))
    weights <- apply(xxhat, 2, function(xi) lhood(y[, i], xi, shape))
    qi <- weights / sum(weights)
    ii <- sample(N, N, TRUE, qi)
    xx.hist[,,i] <- xx <- xxhat[, ii]
    
    hxxhat <- apply(xxhat, 2, h, shape = shape)
    hxx <- apply(xx, 2, h, shape = shape)
    theplot2()
    points(hxxhat[1, ], hxxhat[2, ], pch = 3, col = "#00009070")
    points(hxx[1, ], hxx[2, ], pch = 19, col = "#00990040", cex = 0.5)
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, i], Ytrue[2, i], pch = 19, cex = 0.6, col = "red")
}

rowMeans(xx)
@ 


That's essentially it! The only part missing is how to work with GPS coordinates (instead of
cartesian as in the examples).


\section{GPS Coordinates}

GPS coordinates are angles from the center of the Earth to points above/below the equator (latitude),
and points east/west of the Prime Meridian in Greenwich, England (longitude). However, the relative
scale between latitude and longitude, unlike the examples above, is not 1:1.
Even more, it is not constant across latitudes.
We must therefore transform GPS coordinates so the variances in lon/lat are equal on the ground.


\subsection{A GPS Route}

We'll take a route from Auckland Transport Static GTFS data.
<<AT_route>>=
shapes <- read.csv("data/at_shapes.txt")
plotShape <- function(id) {
    sh <- shapes[shapes$shape_id == id, ]
    plot(sh$shape_pt_lon, sh$shape_pt_lat, type = "l", asp = 1,
         xlab = "Longitude", ylab = "Latitude")
}

plotShape(2)
@ 





\end{document}
