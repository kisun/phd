\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage{parskip}

<<echo=FALSE,results="hide">>=
opts_chunk$set(fig.width=8,fig.height=5,fig.align="center")
library(mvtnorm)
library(RSQLite)
@ 


\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bs}{\boldsymbol{s}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bfn}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bH}{\boldsymbol{H}}
\newcommand{\bK}{\boldsymbol{K}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bZero}{\boldsymbol{0}}
\newcommand{\dd}[2]{\frac{\partial {#1}}{\partial {#2}}}

\newcommand{\X}{\mathrm{X}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\V}{\mathrm{V}}


\newcommand{\pr}{\mathbb{P}}
\renewcommand{\Pr}[1]{\pr\left(#1\right)}


\newcommand{\km}{_{k-1}}
\newcommand{\kk}{_{k|k}}
\newcommand{\kkm}{_{k|k-1}}
\newcommand{\kmkm}{_{k-1|k-1}}


\title{Particle Filter}
\author{Exploration}
\date{}

\begin{document}
\maketitle


\section{Trajectory Constrained tos ``Road''}


We propose a two-stage algorithm that involves several different aspects:

\begin{itemize}
\item GPS location: this is a vector $\by = \left[p_{\mathrm{lat}}, p_{\mathrm{lon}}\right]^T$; we
  must also take into account GPS error (which is typically known, and can at least be estimated).
  

\item Route information: we know where the bus will be going, which reduced the 2-dimentional
  problem down to 1; we need to switch between $\by$ and $d = $ distance into trip.
\end{itemize}


We will be using the following system model, where, at time $k \in 1,\ldots,K$, 
\begin{itemize}
\item 
  $\bx_k$ is the state $\left[d_k, v_k\right]^T$ (= distance-into-trip and velocity, respectively)
  
\item
  $f_k$ is the (assumed known) system transition function, 
  
\item
  $\bu_k$ are the control variables $\left[t_k, \Delta_k\right]^T$ (= time in seconds and time between
  observations, respectively), and
  
\item
  $\bw_k$ is a zero-mean white noise with known distribution $p(\bw_k)$,
  
\end{itemize}
which leads us to:
\begin{equation}
  \label{eq:state_model1}
  \bx_k = 
  f_k\left(\bx_k, \bu_k\right) + \bw_k.
\end{equation}

The second part is the observation equation, which consists of
\begin{itemize}
\item 
  $\by_k$, the observations (GPS coordinates),

\item 
  $h_k$, the measurement function, and

\item 
  $v_k$, the zero-mean, white system noise (e.g., GPS error, \ldots),
\end{itemize}
which come together to give us
\begin{equation}
  \label{eq:state_model2}
  \by_k = 
  h_k\left(\hat\bx_k\right) + \bv_k.
\end{equation}
In our case, $h_k = h$ will map distance-into-trip values to GPS coordinates.
The reason for converting between distance and GPS is to help overcome potential issues that will
arise for example when routes do a ``loop''.


\subsection{Example 1: Straight Trajectory}

In this first example, the ``route'' will be a straight line, observations will be evenly
distributed (i.e., $\Delta_k = \Delta = 1$ for simplicity), and we will use a simple first order
dynamics equation, where $\bw_k$ is the unknown accelaration,
\begin{equation}
  \label{eq:simple_dynamics}
  \bx_k = A\bx_{k-1} + Gw_k,
\end{equation}
where 
$A =
\begin{bmatrix}
  1 & \Delta \\ 0 & 1
\end{bmatrix}$ and 
$G =
\begin{bmatrix}
  \frac{\Delta^2}{2} \\ \Delta
\end{bmatrix}$.
We can later complicate it.

The next part is the mapping from distance to GPS. We will have a single path (with known bearing $\Psi$), so we
can for now get away with (remembering that $d_k = \bx_{1k}$):
\begin{equation}
  \label{eq:d_to_gps}
  h\left(\hat \bx_k\right) = 
  d_k \begin{bmatrix}
    \sin \Psi \\ \cos \Psi
  \end{bmatrix}
\end{equation}


\subsubsection{Simulation Setup}

The ``route'' will start from the origin and end at $\left(20, 15\right)$,
which gives the bearing $\Psi = \tan^{-1}\left(\frac{20}{15}\right)$. 
We then take observations at times $t \in 1, \ldots, 5$~(s), with a constant speed of 3~ms$^{-1}$ from beginning to
end, and ``GPS error'' of 0.5~(m). Thus, the actual positions and simulated observations are:
<<true_positions>>=
set.seed(345346)
Psi <- atan(20/15)
h <- function(x) x[1] * rbind(sin(Psi), cos(Psi))
t <- 1:5
Xtrue <- rbind(t * 3, 3)
Ytrue <- apply(Xtrue, 2, h)
y <- round(Ytrue + t(rmvnorm(length(t), sigma = diag(c(0.5, 0.5)))), 4)

theplot <- function() {
    plot(y[1, ], y[2, ], pch = 19, xlim = c(0, 20), ylim = c(-2, 15), asp = 1,
         xlab = expression(p[lon]), ylab = expression(p[lat]))
    abline(h = 0, v = 0, lty = 3)
    lines(c(0, 20), c(0, 15), lty = 2)
    points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
}
theplot()
@ 


\subsubsection{Simulation Results}

We need a prior distribution on the initial position, which is infact known exactly, however the
speed is unknown:
\begin{equation}
  \label{eq:prior}
  x_0 \sim \mathcal{N}\left(
    \begin{bmatrix}
      0 \\ v_0
    \end{bmatrix},
    \begin{bmatrix}
      0 & 0 \\
      0 & 5
    \end{bmatrix}
  \right),\quad v_0 = 5.
\end{equation}



<<run_pf>>=
lhood <- function(y, x)
    dmvnorm(y, h(x), diag(c(1, 1)))
pw <- function(n)
    rnorm(n, 0, 0.2)
Delta <- 1
A <- cbind(c(1, 0), c(Delta, 1))
G <- rbind(Delta^2/2, Delta)
fn <- function(x, w)
    structure(A %*% x + G %*% w, .Dimnames = list(c("distance", "speed"), NULL))

N <- 200
x0 <- t(rmvnorm(N, c(0, 5), diag(c(0, 5))))
theplot()

x1hat <- fn(x0, pw(N))
hx1hat <- apply(x1hat, 2, h)
points(hx1hat[1, ], hx1hat[2, ], pch = 3, col = "#00009970")

weights <- apply(x1hat, 2, function(xi) lhood(y[, 1], xi))
qi <- weights / sum(weights)
ii <- sample(N, N, TRUE, qi)
x1 <- x1hat[, ii]

hx1 <- apply(x1, 2, h)
points(hx1[1, ], hx1[2, ], pch = 19, col = "#00990040", cex = 0.5)
points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
@ 


Now for the rest of them \ldots

<<run_pf_loop,fig.width=16,fig.height=10>>=
par(mfrow = c(2, 2))
xx <- x1
M <- length(t)
xxhat.hist <- xx.hist <- array(NA, c(2, N, M))
xxhat.hist[,,1] <- x1hat
xx.hist[,,1] <- x1
for (i in t[-1]) {
    xxhat.hist[,,i] <- xxhat <- fn(xx, pw(N))
    weights <- apply(xxhat, 2, function(xi) lhood(y[, i], xi))
    qi <- weights / sum(weights)
    ii <- sample(N, N, TRUE, qi)
    xx.hist[,,i] <- xx <- xxhat[, ii]
    
    hxxhat <- apply(xxhat, 2, h)
    hxx <- apply(xx, 2, h)
    
    theplot()
    points(hxxhat[1, ], hxxhat[2, ], pch = 3, col = "#00009070")
    points(hxx[1, ], hxx[2, ], pch = 19, col = "#00990040", cex = 0.5)
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, i], Ytrue[2, i], pch = 19, cex = 0.6, col = "red")
}

rowMeans(xx)
@ 

<<dist_speed_plot>>=
plot(NA, xlim = range(xxhat.hist[1,,]), ylim = range(xxhat.hist[2,,]),
     xlab = "Distance (m)", ylab = "Speed (m/s)")
cols <- rainbow(M)
colsa <- rainbow(M, alpha = 0.1)
invisible(
    sapply(t, function(ti) {
               points(xxhat.hist[1,,ti], xxhat.hist[2,,ti], pch = 19, col = colsa[ti])
               points(xx.hist[1,,ti], xx.hist[2,,ti], pch = 19, col = cols[ti], cex = 0.3)
           })
    )

@ 



\subsection{Example 2: A Road with Corners}

We will now construct an artifical road that is made up of several segments. Here's the road:

<<road_segments>>=
px <- c(0, 5, 7, 3, -2, -4)
py <- c(0, 3, 6, 8, 7, 2)
road <- function() {
    plot(px, py, type = "l", lty = 2, xlim = c(0, 10), ylim = c(-5, 10), asp = 1,
         xlab = expression(p[lon]), ylab = expression(p[lat]))
    abline(h = 0, v = 0, lty = 3)
}
road()
@ 

Currently, we are \emph{not} using real GPS coordinates, so we don't yet have to worry about
scaling; therefore, we will use simple Euclidean distances to compute the (cumulative) length of
each line segment.

We then take observations at times $t \in 1,\ldots,5$ (s), of a ``vehicle'' travelling at 3~ms$^{-1}$,
again with a ``GPS error'' of 0.5~(m).

<<road_lengths>>=
shape <- data.frame(lon = px, lat = py,
                    distance = c(0, cumsum(sqrt(diff(px)^2 + diff(py)^2))))
shape$distance
@ 

The problem now is converting from distance to cartesian (GPS). This will involve an algorithm of
two steps:
\begin{enumerate}
\item 
  Find the ``point'', $\br_j$, in the shape set that has the smallest positive difference from the
  ``observed'' distance, $d_k$;

\item 
  Calculate the distance into the segment $\bs_j = \overrightarrow{\br_{j}\br_{j+1}} = \br_{j+1}
  - \br_j$, and the bearing of the segment, to calcualte the GPS position of the observation:
  \begin{equation}
    \label{eq:bearing_calc}
    \Psi_j = 
    \begin{cases}
      \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} >= 0, \\
      360 - \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} < 0.
    \end{cases}
  \end{equation}
  
  \begin{equation}
    \label{eq:converstion_formula}
    h_j\left(\hat\bx_k\right) = d_k 
    \begin{bmatrix}
      \sin \Psi_j \\ \cos \Psi_j
    \end{bmatrix}.
  \end{equation}
  
  The subscripts are: $j$ for the segment identification, each which has its own bearing and length,
  and $k$ for the observations (multiple observations can belong to the same segment---useful for
  reducing computations).
  
\end{enumerate}

For the most part, this can be added to the database;
<<segment_stuff>>=
shape$length <- c(sqrt(diff(px)^2 + diff(py)^2), NA)
theta <- 2 * pi - (atan2(diff(py), diff(px)) - pi / 2)
shape$bearing <- c(theta - 2 * pi * (theta >= 2 * pi), NA)
shape

h <- function(x, shape) {
    if (x[1] <= 0) return(c(0, 0))
    if (x[1] >= max(shape$distance)) return(as.numeric(shape[nrow(shape), 1:2]))
    
    j <- which.min(x[1] > shape$distance) - 1
    sj <- shape[j, ]
    Psi <- sj$bearing
    d <- x[1] - sj$distance
    as.numeric(sj[1:2]) + d * c(sin(Psi), cos(Psi))
}

Ytrue <- apply(Xtrue, 2, h, shape = shape)
y <- round(Ytrue + t(rmvnorm(length(t), sigma = diag(c(0.5, 0.5)))), 4)

theplot2 <- function() {
    road()
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
}
theplot2()
@ 

Other than the above, everything else is basically the same!

<<results_ex2>>=
lhood <- function(y, x, shape)
    dmvnorm(y, h(x, shape), diag(c(1, 1)))

N <- 200
x0 <- t(rmvnorm(N, c(0, 5), diag(c(0, 5))))
theplot2()

x1hat <- fn(x0, pw(N))
hx1hat <- apply(x1hat, 2, h, shape = shape)
points(hx1hat[1, ], hx1hat[2, ], pch = 3, col = "#00009970")

weights <- apply(x1hat, 2, function(xi) lhood(y[, 1], xi, shape))
qi <- weights / sum(weights)
ii <- sample(N, N, TRUE, qi)
x1 <- x1hat[, ii]

hx1 <- apply(x1, 2, h, shape = shape)
points(hx1[1, ], hx1[2, ], pch = 19, col = "#00990040", cex = 0.5)
points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
@ 

That look wonderful! Now for the rest \ldots

<<run_pf_loop2,fig.width=6,fig.height=10,out.width="0.6\\textwidth">>=
par(mfrow = c(4, 1))
xx <- x1
M <- length(t)
xxhat.hist <- xx.hist <- array(NA, c(2, N, M))
xxhat.hist[,,1] <- x1hat
xx.hist[,,1] <- x1
for (i in t[-1]) {
    xxhat.hist[,,i] <- xxhat <- fn(xx, pw(N))
    weights <- apply(xxhat, 2, function(xi) lhood(y[, i], xi, shape))
    qi <- weights / sum(weights)
    ii <- sample(N, N, TRUE, qi)
    xx.hist[,,i] <- xx <- xxhat[, ii]
    
    hxxhat <- apply(xxhat, 2, h, shape = shape)
    hxx <- apply(xx, 2, h, shape = shape)
    theplot2()
    points(hxxhat[1, ], hxxhat[2, ], pch = 3, col = "#00009070")
    points(hxx[1, ], hxx[2, ], pch = 19, col = "#00990040", cex = 0.5)
    points(y[1, ], y[2, ], pch = 19)
    points(Ytrue[1, i], Ytrue[2, i], pch = 19, cex = 0.6, col = "red")
}

rowMeans(xx)
@ 


That's essentially it! The only part missing is how to work with GPS coordinates (instead of
cartesian as in the examples).


\section{GPS Coordinates}

GPS coordinates are angles from the center of the Earth to points above/below the equator (latitude),
and points east/west of the Prime Meridian in Greenwich, England (longitude). However, the relative
scale between latitude and longitude, unlike the examples above, is not 1:1.
Even more, it is not constant across latitudes.
We must therefore transform GPS coordinates so the variances in lon/lat are equal on the ground.


\subsection{A GPS Route}

We'll take a route from Auckland Transport Static GTFS data.
<<AT_route>>=
con <- dbConnect(SQLite(), "gtfs.db")
plotShape <- function(id) {
    sh <- dbGetQuery(con, sprintf("SELECT shape_pt_lon AS lon, shape_pt_lat AS lat
                                   FROM shapes WHERE shape_id='%s'", id))
    plot(sh$lon, sh$lat, type = "l", asp = 1,
         xlab = "Longitude", ylab = "Latitude")
    invisible(sh)
}

shapeIDs <- dbGetQuery(con, "SELECT DISTINCT shape_id FROM shapes")
shape1 <- plotShape(shapeIDs[1, 1])
@ 

\subsubsection{GPS Distances}

Now let's say, for example, we have a GPS position for a bus of $\by = [174.78525, -36.84914]^T$.
We want to compare the \emph{distance} of this observation to the positions of the proposed particles.
Let's---for simplicity---assume that we ``uniformly'' place particles at every intersection (i.e.,
each shape point; we can figure out an algorithm to project them between points later).
It therefore seems logical to center all of the particles' coordinates, 
$\bz_i = h(\bx_i)$, on the observation $\by$, and compute
the distances, $e_i$, using a flat-earth approximation (any discrepancies will be minimal due to the small
distances between points). That is, the \emph{equirectangular projection},
which uses Earth's radius $R = 6371000$~m, and after converting to radians ($Q = \frac{\pi}{180}$):
\begin{align*}
  a_i &= Q \left( r_1 - z_{1i} \right) \cos\left(\frac{Q}{2}\left(r_2 + z_{2i}\right)\right) \\
  b_i &= Q\left(r_2 - z_{2i}\right) \\
  e_i &= R \sqrt{a^2 + b^2},
\end{align*}
which can of course be vectorised fairly easily:
<<flat_earth_fn>>=
distanceFlat <- function(y, z, R = 6371000) {
    # computes the distance between {y} and {z}
    # different R (such as in km) give results in those units
    if (length(dim(y)) < 2)
        y <- cbind(y)
    if (length(dim(z)) < 2)
        z <- cbind(z)
    
    if (ncol(y) != ncol(z) & ncol(y) > 1 & ncol(z) > 1)
        stop("Incorrent dimensions")
    
    # need to scale from degrees to radians:
    Q <- pi / 180
    R * sqrt((Q*(z[1,] - y[1, ]) * cos(Q*(y[2, ] + z[2, ]) / 2))^2 + 
             (Q*(z[2, ] - y[2, ]))^2)
}
y <- c(174.78525, -36.84914)
z <- t(shape1)
distanceFlat(y, z)
@ 


\subsubsection{Route Distances}

We can also use the equirectangular projection to compute the length of each segment in the route
path, which we can use to determine distance into trip.
We will compute bearings in the next part.

<<route_distances>>=
# "from" 1->2, 2->3, 3->4, ..., (n-1)->n
y <- z[, -ncol(z)]
z <- z[, -1]
di <- distanceFlat(y, z)
shape1$distance <- c(0, cumsum(di))
shape1$length <- c(di, NA)
shape1[c(1:3, 23:25), ]
@ 

Well, that was easy.

\subsubsection{Route Bearings}

The next part is a little less simple, as the ``bearing'' changes as you move around the Earth in a
straight line.
Not that it will change much over a few hundred meters, we will use the initial bearing, $\theta_k$.
This will be used in the next step when we compute the position given a starting point, bearing, and
a distance traveled. 

First, let's introduce the more standard notation:
$\phi$ is the latitude in radians, and $\lambda$ is the longitude in radians.
We will therefore be moving from $(\phi_k, \lambda_k)$ to $(\phi_{k+1}, \lambda_{k+1})$.
NOTE: the latitude and longitude are reversed from what we have used previously (which was $[$``$x$''$, $``$y$''$]^T$).

\begin{equation}
  \label{eq:bearing_comp}
  \theta_k = 
  \left(\frac{180}{\pi}\mathrm{atan2}\left(
    \sin\left(\Delta\lambda\right) \cos\left(\phi_{k+1}\right),
    \cos\left(\phi_k\right) \sin\left(\phi_{k+1}\right) - 
    \sin\left(\phi_k\right)\cos\left(\phi_{k+1}\right)\cos\left(\Delta\lambda\right)
  \right) + 180\right) \mod 360
\end{equation}
(The modulo converts from a bearing in $[-180^\circ, 180^\circ)$ to $[0^\circ, 360^\circ)$).

<<calc_bearings>>=
bearing <- function(a, b) {
    if (length(dim(a)) < 2) y <- cbind(a)
    if (length(dim(b)) < 2) z <- cbind(b)
    if (ncol(a) != ncol(b) & ncol(a) > 1 & ncol(b) > 1)
        stop("Incorrent dimensions")
    
    b <- b * pi / 180
    a <- a * pi / 180
    
    (atan2(sin(b[1, ] - a[1, ]) * cos(b[2, ]),
           cos(a[2, ]) * sin(b[2, ]) - 
             sin(a[2, ]) * cos(b[2, ]) * cos(b[1, ] - a[1, ])) * 
      180 / pi) %% 360
}
shape1$bearing <- c(bearing(y, z), NA)
head(shape1)
@ 

That was also nice and easy! Well, only because we didn't have to figure out the formula!


\subsubsection{Coordinates of Distance into Segment}

Previously, we used basic trigonometry to figure out the $(X,Y)$ location mid-segment. That doesn't
apply now that we are moving between GPS coordinates.
Fortunately, someone smart figured out the formula for us.

The GPS coordinates of a particle, $\bz = (\lambda_z, \phi_z)$ (dropping the $i$ subscript for simplicity), that travels a
distance of $d$~m from the point $\bs = (\lambda_s, \phi_s)$ at an initial bearing of $\theta^\circ$ is:
\begin{align*}
  \phi_z &= 
  \sin^{-1}\left(
    \sin\left(\phi_s\right) \cos\left(\frac{d}{R}\right) + 
    \cos\left(\phi_s\right)\sin\left(\frac{d}{R}\right)\cos\left(\frac{\pi\theta}{180}\right)
  \right) \\
  \lambda_z &=
  \lambda_s + \frac{180}{\pi}\mathrm{atan2}\left(
    \sin\left(\frac{\pi\theta}{180}\right) \sin\left(\frac{d}{R}\right) \cos\left(\phi_s\right),
    \sin\left(\phi_s\right)\sin\left(\phi_z\right)
  \right)
\end{align*}

Looks simple enough, let's use it. Let's say we are 500~m into the trip:
<<distance_into_trip_calc>>=
partialSegment <- function(x, theta, d, R = 6371000) {
    D <- d / R ## for single calculation
    Th <- theta * pi / 180  ## convert to radians
    X <- x * pi / 180
    
    phi <- asin(sin(X[2]) * cos(D) + cos(X[2]) * sin(D) * cos(Th))
    lambda <- X[1] + atan2(sin(Th) * sin(D) * cos(X[2]),
                           sin(X[2]) * sin(phi))
    c(lambda, phi) * 180 / pi
}
h <- function(x, shape) {
    if (x[1] < 0) return(c0, 0)
    if (x[1] > max(shape$distance)) return(as.numeric(shape[nrow(shape), 1:2]))
    
    j <- which.min(x[1] > shape$distance) - 1
    sj <- shape[j, ]
    Psi <- sj$bearing
    d <- x[1] - sj$distance
    
    ## only do the calculations if we need to!
    if (d == 0) return(as.numeric(sj[1:2]))
    
    partialSegment(as.numeric(sj[1:2]), Psi, d)
}
x <- c(500, NA)
z <- h(x, shape1)

plotShape(shapeIDs[1, 1])
points(z[1], z[2], col = "red", pch = 19)

## how about a bunch of points:
x <- rbind(seq(shape1$distance[8], shape1$distance[11], length = 101), NA)
z <- apply(x, 2, h, shape = shape1)

points(z[1, ], z[2, ], col = "blue", pch = 19, cex = 0.2)

points(shape1$lon[7], shape1$lat[7], pch = 19, cex = 0.4)
@ 
\end{document}
