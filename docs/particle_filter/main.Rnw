\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage{parskip}

<<echo=FALSE,results="hide">>=
opts_chunk$set(fig.width=8,fig.height=5,fig.align="center")
library(mvtnorm)
@ 


\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bfn}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bH}{\boldsymbol{H}}
\newcommand{\bK}{\boldsymbol{K}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bZero}{\boldsymbol{0}}
\newcommand{\dd}[2]{\frac{\partial {#1}}{\partial {#2}}}

\newcommand{\X}{\mathrm{X}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\V}{\mathrm{V}}


\newcommand{\pr}{\mathbb{P}}
\renewcommand{\Pr}[1]{\pr\left(#1\right)}


\newcommand{\km}{_{k-1}}
\newcommand{\kk}{_{k|k}}
\newcommand{\kkm}{_{k|k-1}}
\newcommand{\kmkm}{_{k-1|k-1}}


\title{Particle Filter}
\author{Exploration}
\date{}

\begin{document}
\maketitle


\section{Straight Trajectory, Unconstrained}

An example in two-dimensions where the object travels in a straight trajectory. 


<<first>>=
x <- c(0, 40)
y <- c(0, 15)
t <- 1
plot(x, y, type = "l", xlim = c(0, 20), ylim = c(-20, 20), asp = 1, pch = 19)
abline(h = 0, v = 0, lty = 3)
@ 

We can write the formula for movement as:
\begin{equation}
  \label{eq:straight_state}
  \X_k = \X_{k-1} + \V_{k-1}t_{k} + \E_kt_{k},
\end{equation}
where 
$\X_k = \left[x_k, y_k\right]^T$ are the coordinates at time $k$,
$\V_k = \left[\dot x_k, \dot y_k\right]^T$ are the $x$ and $y$ velocities at time $k$,
and $t_k$ is the time between steps $k-1$ and $k$; here, using uniform discrete time, $t_k = t$.
The error term is (for now) Gaussian zero-mean white-noise, $\E_k \sim \mathcal{N}\left(0, \Sigma_k\right)$,
$\Sigma_k = \Sigma =
\begin{bmatrix}
  \sigma_x^2 & 0 \\ 0 & \sigma_y^2
\end{bmatrix}$,
$\sigma_x^2 = 2$, $\sigma_y^2 = 3$.
For now, for velocity we will use $\dot x_k = \frac{x_k - x_{k-1}}{t_k}$, and likewise for $\dot y_k$.


So let us predict the next step, k = 2:
\begin{equation}
  \label{eq:predict}
  \hat \X_k = \X_{k-1} + \V_{k-1}t_k
\end{equation}
<<step_2>>=
X2 <- rbind(x[2], y[2])
V2 <- rbind(x[2] - x[1], y[2] - y[1]) ## t = 1
Sigma <- cbind(c(2, 0), c(0, 3))

(X3hat <- X2 + V2 %*% t)

plot(x, y, type = "b", xlim = c(0, 20), ylim = c(-20, 20), asp = 1, pch = 19)
abline(h = 0, v = 0, lty = 3)
points(X3hat[1], X3hat[2], pch = 3, col = "red")
@ 



That was easy enough! Now do it with particles\ldots

Require prior distribution $p\left(\X_0\right) \sim \mathcal{N}\left(\bZero, \Sigma_0\right)$,
$\Sigma_0 =
\begin{bmatrix}
  5 & 0 \\ 0 & 5
\end{bmatrix}$.

Step 1: sample the particles:
<<sample_particles>>=
N <- 500  ## for simplicity!!
X <- rmvnorm(N, sigma = diag(c(5, 5)))

plot(x, y, type = "b", xlim = c(0, 20), ylim = c(-20, 20), asp = 1, pch = 19)
abline(h = 0, v = 0, lty = 3)
points(X[, 1], X[, 2], pch = 19, cex = 0.4, col = "#00000030")
@ 

Let's assume we know the direction they'll be travelling:
<<particle_step1>>=
V <- V2
Xhats <- t(t(X) + V %*% rep(t, N))
Xprop <- Xhats + rmvnorm(N, sigma = Sigma)

plot(x, y, type = "b", xlim = c(0, 20), ylim = c(-20, 20), asp = 1, pch = 19)
abline(h = 0, v = 0, lty = 3)
points(Xprop[, 1], Xprop[, 2], pch = 19, cex = 0.4, col = "#0000FF30")
@ 

Now bootstrap by weights using 
\begin{equation}
  \label{eq:particle_weights}
  q_i = \frac{p\left(y_k | x_k^\star(i)\right)}{\sum_j p\left(y_k | x_k^\star(j)\right)},
  \quad
  p\left(y_k | x_k^\star\right) \sim \mathcal{N}\left(x_k^\star, R\right),
\end{equation}
where $R =
\begin{bmatrix}
  3 & 0 \\ 0 & 3
\end{bmatrix}$.

<<particle_weights>>=
R = diag(c(3, 3))
wi <- apply(Xprop, 1, function(xi) dmvnorm(t(X2), xi, R))
qi <- wi / sum(wi)

i <- sample(N, N, TRUE, prob = qi)
X <- Xprop[i, ]

plot(x, y, type = "b", xlim = c(0, 20), ylim = c(-20, 20), asp = 1, pch = 19)
abline(h = 0, v = 0, lty = 3)
points(X[, 1], X[, 2], pch = 19, cex = 0.4, col = "#00000030")
@ 


\vfill
\newpage
\section{Trajectory Constrained to ``Road''}


We propose a two-stage algorithm that involves several different aspects:

\begin{itemize}
\item GPS location: this is a vector $\by = \left[p_{\mathrm{lat}}, p_{\mathrm{lon}}\right]^T$; we
  must also take into account GPS error (which is typically known, and can at least be estimated).
  

\item Route information: we know where the bus will be going, which reduced the 2-dimentional
  problem down to 1; we need to switch between $\by$ and $d = $ distance into trip.
\end{itemize}


We will be using the following system model, where, at time $k \in 1,\ldots,K$, 
\begin{itemize}
\item 
  $\bx_k$ is the state $\left[d_k, v_k\right]^T$ (= distance-into-trip and velocity, respectively)
  
\item
  $f_k$ is the (assumed known) system transition function, 
  
\item
  $\bu_k$ are the control variables $\left[t_k, \Delta_k\right]^T$ (= time in seconds and time between
  observations, respectively), and
  
\item
  $\bw_k$ is a zero-mean white noise with known distribution $p(\bw_k)$,
  
\end{itemize}
which leads us to:
\begin{equation}
  \label{eq:state_model1}
  \bx_k = 
  f_k\left(\bx_k, \bu_k\right) + \bw_k.
\end{equation}

The second part is the observation equation, which consists of
\begin{itemize}
\item 
  $\by_k$, the observations (GPS coordinates),

\item 
  $h_k$, the measurement function, and

\item 
  $v_k$, the zero-mean, white system noise (e.g., GPS error, \ldots),
\end{itemize}
which come together to give us
\begin{equation}
  \label{eq:state_model2}
  \by_k = 
  h_k\left(\hat\bx_k\right) + \bv_k.
\end{equation}
In our case, $h_k = h$ will map distance-into-trip values to GPS coordinates.
The reason for converting between distance and GPS is to help overcome potential issues that will
arise for example when routes do a ``loop''.


\subsection{Example 1}

In this first example, the ``route'' will be a straight line, observations will be evenly
distributed (i.e., $\Delta_k = \Delta = 1$ for simplicity), and we will use a simple first order
dynamics equation, where $\bw_k$ is the unknown accelaration,
\begin{equation}
  \label{eq:simple_dynamics}
  \bx_k = A\bx_{k-1} + Gw_k,
\end{equation}
where 
$A =
\begin{bmatrix}
  1 & \Delta \\ 0 & 1
\end{bmatrix}$ and 
$G =
\begin{bmatrix}
  \frac{\Delta^2}{2} \\ \Delta
\end{bmatrix}$.
We can later complicate it.

The next part is the mapping from distance to GPS. We will have a single path (with known bearing $\Psi$), so we
can for now get away with (remembering that $d_k = \bx_{1k}$):
\begin{equation}
  \label{eq:d_to_gps}
  h\left(\hat \bx_k\right) = 
  d_k \begin{bmatrix}
    \sin \Psi \\ \cos \Psi
  \end{bmatrix}
\end{equation}


\subsubsection{Simulation Setup}

The ``route'' will start from the origin and end at $\left(20, 15\right)$,
which gives the bearing $\Psi = \tan^{-1}\left(\frac{20}{15}\right)$. 
We then take observations at times $t \in 1, \ldots, 5$~(s), with a constant speed of 3~ms$^{-1}$ from beginning to
end, and ``GPS error'' of 0.5~(m). Thus, the actual positions and simulated observations are:
<<true_positions>>=
set.seed(345346)
Psi <- atan(20/15)
h <- function(x) x[1] * rbind(sin(Psi), cos(Psi))
t <- 1:5
Xtrue <- rbind(c(0, t * 3), 3)
Ytrue <- apply(Xtrue, 2, h)
y <- round(Ytrue + t(rmvnorm(length(t) + 1, sigma = diag(c(0.5, 0.5)))), 4)

theplot <- function() {
    plot(y[1, ], y[2, ], pch = 19, xlim = c(0, 20), ylim = c(-2, 15), asp = 1,
         xlab = expression(p[lon]), ylab = expression(p[lat]))
    abline(h = 0, v = 0, lty = 3)
    lines(c(0, 20), c(0, 15), lty = 2)
    points(Ytrue[1, ], Ytrue[2, ], pch = 19, cex = 0.3, col = "red")
}
theplot()
@ 


\subsubsection{Simulation Results}

We need a prior distribution on the initial position, which is infact known exactly, however the
speed is unknown:
\begin{equation}
  \label{eq:prior}
  x_0 \sim \mathcal{N}\left(
    \begin{bmatrix}
      0 \\ v_0
    \end{bmatrix},
    \begin{bmatrix}
      0 & 0 \\
      0 & 5
    \end{bmatrix}
  \right),\quad v_0 = 5.
\end{equation}



<<run_pf,fig.height=10>>=
lhood <- function(y, x)
    dmvnorm(y, x, diag(c(0.5, 0.5)))
pw <- function(n)
    rnorm(n, 0, 2)
Delta <- 1
A <- cbind(c(1, 0), c(Delta, 1))
G <- rbind(Delta^2/2, Delta)
fn <- function(x, w)
    A %*% x + G %*% w

par(mfrow = c(2, 1))
N <- 20
x0 <- t(rmvnorm(N, c(0, 5), diag(c(0, 5))))
theplot()

x1hat <- fn(x0, pw(N))
hx1hat <- apply(x1hat, 2, h)
points(hx1hat[1, ], hx1hat[2, ], pch = 19, cex = 0.5, col = "#00009970")
@ 




\end{document}
