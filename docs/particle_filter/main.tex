\documentclass[11pt]{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage{parskip}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: DBI}}\end{kframe}
\end{knitrout}


\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bY}{\boldsymbol{Y}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bs}{\boldsymbol{s}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bfn}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bg}{\boldsymbol{g}}
\newcommand{\bH}{\boldsymbol{2H}}
\newcommand{\bK}{\boldsymbol{K}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bZero}{\boldsymbol{0}}
\newcommand{\dd}[2]{\frac{\partial {#1}}{\partial {#2}}}

\newcommand{\X}{\mathrm{X}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\V}{\mathrm{V}}


\newcommand{\pr}{\mathbb{P}}
\renewcommand{\Pr}[1]{\pr\left(#1\right)}


\newcommand{\km}{_{k-1}}
\newcommand{\kk}{_{k|k}}
\newcommand{\kkm}{_{k|k-1}}
\newcommand{\kmkm}{_{k-1|k-1}}


\title{Particle Filter}
\author{Exploration}
\date{}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
\maketitle


\section{Trajectory Constrained tos ``Road''}


We propose a two-stage algorithm that involves several different aspects:

\begin{itemize}
\item GPS location: this is a vector $\by = \left[p_{\mathrm{lat}}, p_{\mathrm{lon}}\right]^T$; we
  must also take into account GPS error (which is typically known, and can at least be estimated).
  

\item Route information: we know where the bus will be going, which reduced the 2-dimentional
  problem down to 1; we need to switch between $\by$ and $d = $ distance into trip.
\end{itemize}


We will be using the following system model, where, at time $k \in 1,\ldots,K$, 
\begin{itemize}
\item 
  $\bx_k$ is the state $\left[d_k, v_k\right]^T$ (= distance-into-trip and velocity, respectively)
  
\item
  $f_k$ is the (assumed known) system transition function, 
  
\item
  $\bu_k$ are the control variables $\left[t_k, \Delta_k\right]^T$ (= time in seconds and time between
  observations, respectively), and
  
\item
  $\bw_k$ is a zero-mean white noise with known distribution $p(\bw_k)$,
  
\end{itemize}
which leads us to:
\begin{equation}
  \label{eq:state_model1}
  \bx_k = 
  f_k\left(\bx_k, \bu_k\right) + \bw_k.
\end{equation}

The second part is the observation equation, which consists of
\begin{itemize}
\item 
  $\by_k$, the observations (GPS coordinates),

\item 
  $h_k$, the measurement function, and

\item 
  $v_k$, the zero-mean, white system noise (e.g., GPS error, \ldots),
\end{itemize}
which come together to give us
\begin{equation}
  \label{eq:state_model2}
  \by_k = 
  h_k\left(\hat\bx_k\right) + \bv_k.
\end{equation}
In our case, $h_k = h$ will map distance-into-trip values to GPS coordinates.
The reason for converting between distance and GPS is to help overcome potential issues that will
arise for example when routes do a ``loop''.


\subsection{Example 1: Straight Trajectory}

In this first example, the ``route'' will be a straight line, observations will be evenly
distributed (i.e., $\Delta_k = \Delta = 1$ for simplicity), and we will use a simple first order
dynamics equation, where $\bw_k$ is the unknown accelaration,
\begin{equation}
  \label{eq:simple_dynamics}
  \bx_k = A\bx_{k-1} + Gw_k,
\end{equation}
where 
$A =
\begin{bmatrix}
  1 & \Delta \\ 0 & 1
\end{bmatrix}$ and 
$G =
\begin{bmatrix}
  \frac{\Delta^2}{2} \\ \Delta
\end{bmatrix}$.
We can later complicate it.

The next part is the mapping from distance to GPS. We will have a single path (with known bearing $\Psi$), so we
can for now get away with (remembering that $d_k = \bx_{1k}$):
\begin{equation}
  \label{eq:d_to_gps}
  h\left(\hat \bx_k\right) = 
  d_k \begin{bmatrix}
    \sin \Psi \\ \cos \Psi
  \end{bmatrix}
\end{equation}


\subsubsection{Simulation Setup}

The ``route'' will start from the origin and end at $\left(20, 15\right)$,
which gives the bearing $\Psi = \tan^{-1}\left(\frac{20}{15}\right)$. 
We then take observations at times $t \in 1, \ldots, 5$~(s), with a constant speed of 3~ms$^{-1}$ from beginning to
end, and ``GPS error'' of 0.5~(m). Thus, the actual positions and simulated observations are:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{345346}\hlstd{)}
\hlstd{Psi} \hlkwb{<-} \hlkwd{atan}\hlstd{(}\hlnum{20}\hlopt{/}\hlnum{15}\hlstd{)}
\hlstd{h} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) x[}\hlnum{1}\hlstd{]} \hlopt{*} \hlkwd{rbind}\hlstd{(}\hlkwd{sin}\hlstd{(Psi),} \hlkwd{cos}\hlstd{(Psi))}
\hlstd{t} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{5}
\hlstd{Xtrue} \hlkwb{<-} \hlkwd{rbind}\hlstd{(t} \hlopt{*} \hlnum{3}\hlstd{,} \hlnum{3}\hlstd{)}
\hlstd{Ytrue} \hlkwb{<-} \hlkwd{apply}\hlstd{(Xtrue,} \hlnum{2}\hlstd{, h)}
\hlstd{y} \hlkwb{<-} \hlkwd{round}\hlstd{(Ytrue} \hlopt{+} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(}\hlkwd{length}\hlstd{(t),} \hlkwc{sigma} \hlstd{=} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{0.5}\hlstd{)))),} \hlnum{4}\hlstd{)}

\hlstd{theplot} \hlkwb{<-} \hlkwa{function}\hlstd{() \{}
    \hlkwd{plot}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{xlim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwc{ylim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{2}\hlstd{,} \hlnum{15}\hlstd{),} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
         \hlkwc{xlab} \hlstd{=} \hlkwd{expression}\hlstd{(p[lon]),} \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(p[lat]))}
    \hlkwd{abline}\hlstd{(}\hlkwc{h} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{v} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{3}\hlstd{)}
    \hlkwd{lines}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{15}\hlstd{),} \hlkwc{lty} \hlstd{=} \hlnum{2}\hlstd{)}
    \hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, ], Ytrue[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\hlstd{\}}
\hlkwd{theplot}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/true_positions-1} 

}



\end{knitrout}


\subsubsection{Simulation Results}

We need a prior distribution on the initial position, which is infact known exactly, however the
speed is unknown:
\begin{equation}
  \label{eq:prior}
  x_0 \sim \mathcal{N}\left(
    \begin{bmatrix}
      0 \\ v_0
    \end{bmatrix},
    \begin{bmatrix}
      0 & 0 \\
      0 & 5
    \end{bmatrix}
  \right),\quad v_0 = 5.
\end{equation}



\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lhood} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{x}\hlstd{)}
    \hlkwd{dmvnorm}\hlstd{(y,} \hlkwd{h}\hlstd{(x),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{)))}
\hlstd{pw} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{n}\hlstd{)}
    \hlkwd{rnorm}\hlstd{(n,} \hlnum{0}\hlstd{,} \hlnum{0.2}\hlstd{)}
\hlstd{Delta} \hlkwb{<-} \hlnum{1}
\hlstd{A} \hlkwb{<-} \hlkwd{cbind}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{0}\hlstd{),} \hlkwd{c}\hlstd{(Delta,} \hlnum{1}\hlstd{))}
\hlstd{G} \hlkwb{<-} \hlkwd{rbind}\hlstd{(Delta}\hlopt{^}\hlnum{2}\hlopt{/}\hlnum{2}\hlstd{, Delta)}
\hlstd{fn} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{w}\hlstd{)}
    \hlkwd{structure}\hlstd{(A} \hlopt{%*%} \hlstd{x} \hlopt{+} \hlstd{G} \hlopt{%*%} \hlstd{w,} \hlkwc{.Dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"distance"}\hlstd{,} \hlstr{"speed"}\hlstd{),} \hlkwa{NULL}\hlstd{))}

\hlstd{N} \hlkwb{<-} \hlnum{200}
\hlstd{x0} \hlkwb{<-} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(N,} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{))))}
\hlkwd{theplot}\hlstd{()}

\hlstd{x1hat} \hlkwb{<-} \hlkwd{fn}\hlstd{(x0,} \hlkwd{pw}\hlstd{(N))}
\hlstd{hx1hat} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{, h)}
\hlkwd{points}\hlstd{(hx1hat[}\hlnum{1}\hlstd{, ], hx1hat[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009970"}\hlstd{)}

\hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[,} \hlnum{1}\hlstd{], xi))}
\hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
\hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
\hlstd{x1} \hlkwb{<-} \hlstd{x1hat[, ii]}

\hlstd{hx1} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1,} \hlnum{2}\hlstd{, h)}
\hlkwd{points}\hlstd{(hx1[}\hlnum{1}\hlstd{, ], hx1[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990040"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{)}
\hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, ], Ytrue[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/run_pf-1} 

}



\end{knitrout}


Now for the rest of them \ldots

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{2}\hlstd{))}
\hlstd{xx} \hlkwb{<-} \hlstd{x1}
\hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(t)}
\hlstd{xxhat.hist} \hlkwb{<-} \hlstd{xx.hist} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{, N, M))}
\hlstd{xxhat.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1hat}
\hlstd{xx.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlstd{t[}\hlopt{-}\hlnum{1}\hlstd{]) \{}
    \hlstd{xxhat.hist[,,i]} \hlkwb{<-} \hlstd{xxhat} \hlkwb{<-} \hlkwd{fn}\hlstd{(xx,} \hlkwd{pw}\hlstd{(N))}
    \hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[, i], xi))}
    \hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
    \hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
    \hlstd{xx.hist[,,i]} \hlkwb{<-} \hlstd{xx} \hlkwb{<-} \hlstd{xxhat[, ii]}

    \hlstd{hxxhat} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{, h)}
    \hlstd{hxx} \hlkwb{<-} \hlkwd{apply}\hlstd{(xx,} \hlnum{2}\hlstd{, h)}

    \hlkwd{theplot}\hlstd{()}
    \hlkwd{points}\hlstd{(hxxhat[}\hlnum{1}\hlstd{, ], hxxhat[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009070"}\hlstd{)}
    \hlkwd{points}\hlstd{(hxx[}\hlnum{1}\hlstd{, ], hxx[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990040"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{)}
    \hlkwd{points}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
    \hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, i], Ytrue[}\hlnum{2}\hlstd{, i],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/run_pf_loop-1} 

}


\begin{kframe}\begin{alltt}
\hlkwd{rowMeans}\hlstd{(xx)}
\end{alltt}
\begin{verbatim}
##  distance     speed 
## 15.583953  3.148476
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{xlim} \hlstd{=} \hlkwd{range}\hlstd{(xxhat.hist[}\hlnum{1}\hlstd{,,]),} \hlkwc{ylim} \hlstd{=} \hlkwd{range}\hlstd{(xxhat.hist[}\hlnum{2}\hlstd{,,]),}
     \hlkwc{xlab} \hlstd{=} \hlstr{"Distance (m)"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Speed (m/s)"}\hlstd{)}
\hlstd{cols} \hlkwb{<-} \hlkwd{rainbow}\hlstd{(M)}
\hlstd{colsa} \hlkwb{<-} \hlkwd{rainbow}\hlstd{(M,} \hlkwc{alpha} \hlstd{=} \hlnum{0.1}\hlstd{)}
\hlkwd{invisible}\hlstd{(}
    \hlkwd{sapply}\hlstd{(t,} \hlkwa{function}\hlstd{(}\hlkwc{ti}\hlstd{) \{}
               \hlkwd{points}\hlstd{(xxhat.hist[}\hlnum{1}\hlstd{,,ti], xxhat.hist[}\hlnum{2}\hlstd{,,ti],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{= colsa[ti])}
               \hlkwd{points}\hlstd{(xx.hist[}\hlnum{1}\hlstd{,,ti], xx.hist[}\hlnum{2}\hlstd{,,ti],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{= cols[ti],} \hlkwc{cex} \hlstd{=} \hlnum{0.3}\hlstd{)}
           \hlstd{\})}
    \hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/dist_speed_plots-1} 

}



\end{knitrout}



\subsection{Example 2: A Road with Corners}

We will now construct an artifical road that is made up of several segments. Here's the road:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{px} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{7}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{2}\hlstd{,} \hlopt{-}\hlnum{4}\hlstd{)}
\hlstd{py} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{,} \hlnum{7}\hlstd{,} \hlnum{2}\hlstd{)}
\hlstd{road} \hlkwb{<-} \hlkwa{function}\hlstd{() \{}
    \hlkwd{plot}\hlstd{(px, py,} \hlkwc{type} \hlstd{=} \hlstr{"l"}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{xlim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwc{ylim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{5}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
         \hlkwc{xlab} \hlstd{=} \hlkwd{expression}\hlstd{(p[lon]),} \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(p[lat]))}
    \hlkwd{abline}\hlstd{(}\hlkwc{h} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{v} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{3}\hlstd{)}
\hlstd{\}}
\hlkwd{road}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/road_segments-1} 

}



\end{knitrout}

Currently, we are \emph{not} using real GPS coordinates, so we don't yet have to worry about
scaling; therefore, we will use simple Euclidean distances to compute the (cumulative) length of
each line segment.

We then take observations at times $t \in 1,\ldots,5$ (s), of a ``vehicle'' travelling at 3~ms$^{-1}$,
again with a ``GPS error'' of 0.5~(m).

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{shape} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{lon} \hlstd{= px,} \hlkwc{lat} \hlstd{= py,}
                    \hlkwc{distance} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwd{cumsum}\hlstd{(}\hlkwd{sqrt}\hlstd{(}\hlkwd{diff}\hlstd{(px)}\hlopt{^}\hlnum{2} \hlopt{+} \hlkwd{diff}\hlstd{(py)}\hlopt{^}\hlnum{2}\hlstd{))))}
\hlstd{shape}\hlopt{$}\hlstd{distance}
\end{alltt}
\begin{verbatim}
## [1]  0.000000  5.830952  9.436503 13.908639 19.007659 24.392823
\end{verbatim}
\end{kframe}
\end{knitrout}

The problem now is converting from distance to cartesian (GPS). This will involve an algorithm of
two steps:
\begin{enumerate}
\item 
  Find the ``point'', $\br_j$, in the shape set that has the smallest positive difference from the
  ``observed'' distance, $d_k$;

\item 
  Calculate the distance into the segment $\bs_j = \overrightarrow{\br_{j}\br_{j+1}} = \br_{j+1}
  - \br_j$, and the bearing of the segment, to calcualte the GPS position of the observation:
  \begin{equation}
    \label{eq:bearing_calc}
    \Psi_j = 
    \begin{cases}
      \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} >= 0, \\
      360 - \tan^{-1} \frac{s_{j1}}{s_{j2}}, & r_{j1} < 0.
    \end{cases}
  \end{equation}
  
  \begin{equation}
    \label{eq:converstion_formula}
    h_j\left(\hat\bx_k\right) = d_k 
    \begin{bmatrix}
      \sin \Psi_j \\ \cos \Psi_j
    \end{bmatrix}.
  \end{equation}
  
  The subscripts are: $j$ for the segment identification, each which has its own bearing and length,
  and $k$ for the observations (multiple observations can belong to the same segment---useful for
  reducing computations).
  
\end{enumerate}

For the most part, this can be added to the database;
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{shape}\hlopt{$}\hlstd{length} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{sqrt}\hlstd{(}\hlkwd{diff}\hlstd{(px)}\hlopt{^}\hlnum{2} \hlopt{+} \hlkwd{diff}\hlstd{(py)}\hlopt{^}\hlnum{2}\hlstd{),} \hlnum{NA}\hlstd{)}
\hlstd{theta} \hlkwb{<-} \hlnum{2} \hlopt{*} \hlstd{pi} \hlopt{-} \hlstd{(}\hlkwd{atan2}\hlstd{(}\hlkwd{diff}\hlstd{(py),} \hlkwd{diff}\hlstd{(px))} \hlopt{-} \hlstd{pi} \hlopt{/} \hlnum{2}\hlstd{)}
\hlstd{shape}\hlopt{$}\hlstd{bearing} \hlkwb{<-} \hlkwd{c}\hlstd{(theta} \hlopt{-} \hlnum{2} \hlopt{*} \hlstd{pi} \hlopt{*} \hlstd{(theta} \hlopt{>=} \hlnum{2} \hlopt{*} \hlstd{pi),} \hlnum{NA}\hlstd{)}
\hlstd{shape}
\end{alltt}
\begin{verbatim}
##   lon lat  distance   length   bearing
## 1   0   0  0.000000 5.830952 1.0303768
## 2   5   3  5.830952 3.605551 0.5880026
## 3   7   6  9.436503 4.472136 5.1760366
## 4   3   8 13.908639 5.099020 4.5149934
## 5  -2   7 19.007659 5.385165 3.5220990
## 6  -4   2 24.392823       NA        NA
\end{verbatim}
\begin{alltt}
\hlstd{h} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{shape}\hlstd{) \{}
    \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{<=} \hlnum{0}\hlstd{)} \hlkwd{return}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0}\hlstd{))}
    \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>=} \hlkwd{max}\hlstd{(shape}\hlopt{$}\hlstd{distance))} \hlkwd{return}\hlstd{(}\hlkwd{as.numeric}\hlstd{(shape[}\hlkwd{nrow}\hlstd{(shape),} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]))}

    \hlstd{j} \hlkwb{<-} \hlkwd{which.min}\hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>} \hlstd{shape}\hlopt{$}\hlstd{distance)} \hlopt{-} \hlnum{1}
    \hlstd{sj} \hlkwb{<-} \hlstd{shape[j, ]}
    \hlstd{Psi} \hlkwb{<-} \hlstd{sj}\hlopt{$}\hlstd{bearing}
    \hlstd{d} \hlkwb{<-} \hlstd{x[}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{sj}\hlopt{$}\hlstd{distance}
    \hlkwd{as.numeric}\hlstd{(sj[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{])} \hlopt{+} \hlstd{d} \hlopt{*} \hlkwd{c}\hlstd{(}\hlkwd{sin}\hlstd{(Psi),} \hlkwd{cos}\hlstd{(Psi))}
\hlstd{\}}

\hlstd{Ytrue} \hlkwb{<-} \hlkwd{apply}\hlstd{(Xtrue,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape)}
\hlstd{y} \hlkwb{<-} \hlkwd{round}\hlstd{(Ytrue} \hlopt{+} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(}\hlkwd{length}\hlstd{(t),} \hlkwc{sigma} \hlstd{=} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{0.5}\hlstd{)))),} \hlnum{4}\hlstd{)}

\hlstd{theplot2} \hlkwb{<-} \hlkwa{function}\hlstd{() \{}
    \hlkwd{road}\hlstd{()}
    \hlkwd{points}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
    \hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, ], Ytrue[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\hlstd{\}}
\hlkwd{theplot2}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/segment_stuff-1} 

}



\end{knitrout}

Other than the above, everything else is basically the same!

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lhood} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{x}\hlstd{,} \hlkwc{shape}\hlstd{)}
    \hlkwd{dmvnorm}\hlstd{(y,} \hlkwd{h}\hlstd{(x, shape),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{)))}

\hlstd{N} \hlkwb{<-} \hlnum{200}
\hlstd{x0} \hlkwb{<-} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(N,} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{))))}
\hlkwd{theplot2}\hlstd{()}

\hlstd{x1hat} \hlkwb{<-} \hlkwd{fn}\hlstd{(x0,} \hlkwd{pw}\hlstd{(N))}
\hlstd{hx1hat} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape)}
\hlkwd{points}\hlstd{(hx1hat[}\hlnum{1}\hlstd{, ], hx1hat[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009970"}\hlstd{)}

\hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[,} \hlnum{1}\hlstd{], xi, shape))}
\hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
\hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
\hlstd{x1} \hlkwb{<-} \hlstd{x1hat[, ii]}

\hlstd{hx1} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape)}
\hlkwd{points}\hlstd{(hx1[}\hlnum{1}\hlstd{, ], hx1[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990040"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{)}
\hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, ], Ytrue[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/results_ex2-1} 

}



\end{knitrout}

That look wonderful! Now for the rest \ldots

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{1}\hlstd{))}
\hlstd{xx} \hlkwb{<-} \hlstd{x1}
\hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(t)}
\hlstd{xxhat.hist} \hlkwb{<-} \hlstd{xx.hist} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{, N, M))}
\hlstd{xxhat.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1hat}
\hlstd{xx.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlstd{t[}\hlopt{-}\hlnum{1}\hlstd{]) \{}
    \hlstd{xxhat.hist[,,i]} \hlkwb{<-} \hlstd{xxhat} \hlkwb{<-} \hlkwd{fn}\hlstd{(xx,} \hlkwd{pw}\hlstd{(N))}
    \hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[, i], xi, shape))}
    \hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
    \hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
    \hlstd{xx.hist[,,i]} \hlkwb{<-} \hlstd{xx} \hlkwb{<-} \hlstd{xxhat[, ii]}

    \hlstd{hxxhat} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape)}
    \hlstd{hxx} \hlkwb{<-} \hlkwd{apply}\hlstd{(xx,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape)}
    \hlkwd{theplot2}\hlstd{()}
    \hlkwd{points}\hlstd{(hxxhat[}\hlnum{1}\hlstd{, ], hxxhat[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009070"}\hlstd{)}
    \hlkwd{points}\hlstd{(hxx[}\hlnum{1}\hlstd{, ], hxx[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990040"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{)}
    \hlkwd{points}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
    \hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, i], Ytrue[}\hlnum{2}\hlstd{, i],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.6\textwidth]{figure/run_pf_loop2-1} 

}


\begin{kframe}\begin{alltt}
\hlkwd{rowMeans}\hlstd{(xx)}
\end{alltt}
\begin{verbatim}
##  distance     speed 
## 15.158491  2.963134
\end{verbatim}
\end{kframe}
\end{knitrout}


That's essentially it! The only part missing is how to work with GPS coordinates (instead of
cartesian as in the examples).


\section{GPS Coordinates}

GPS coordinates are angles from the center of the Earth to points above/below the equator (latitude),
and points east/west of the Prime Meridian in Greenwich, England (longitude). However, the relative
scale between latitude and longitude, unlike the examples above, is not 1:1.
Even more, it is not constant across latitudes.
We must therefore transform GPS coordinates so the variances in lon/lat are equal on the ground.


\subsection{A GPS Route}

We'll take a route from Auckland Transport Static GTFS data.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{con} \hlkwb{<-} \hlkwd{dbConnect}\hlstd{(}\hlkwd{SQLite}\hlstd{(),} \hlstr{"gtfs.db"}\hlstd{)}
\hlstd{plotShape} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{id}\hlstd{,} \hlkwc{conn} \hlstd{= con) \{}
    \hlstd{sh} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(conn,} \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT shape_pt_lon AS lon, shape_pt_lat AS lat
                                   FROM shapes WHERE shape_id='%s'"}\hlstd{, id))}
    \hlkwd{plot}\hlstd{(sh}\hlopt{$}\hlstd{lon, sh}\hlopt{$}\hlstd{lat,} \hlkwc{type} \hlstd{=} \hlstr{"l"}\hlstd{,} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
         \hlkwc{xlab} \hlstd{=} \hlstr{"Longitude"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Latitude"}\hlstd{)}
    \hlkwd{points}\hlstd{(sh}\hlopt{$}\hlstd{lon[}\hlnum{1}\hlstd{], sh}\hlopt{$}\hlstd{lat[}\hlnum{1}\hlstd{],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
    \hlkwd{invisible}\hlstd{(sh)}
\hlstd{\}}

\hlstd{shapeIDs} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(con,} \hlstr{"SELECT DISTINCT shape_id FROM shapes"}\hlstd{)}
\hlstd{shape1} \hlkwb{<-} \hlkwd{plotShape}\hlstd{(shapeIDs[}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{], con)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/AT_route-1} 

}



\end{knitrout}

\subsubsection{GPS Distances}

Now let's say, for example, we have a GPS position for a bus of $\by = [174.78525, -36.84914]^T$.
We want to compare the \emph{distance} of this observation to the positions of the proposed particles.
Let's---for simplicity---assume that we ``uniformly'' place particles at every intersection (i.e.,
each shape point; we can figure out an algorithm to project them between points later).
It therefore seems logical to center all of the particles' coordinates, 
$\bz_i = h(\bx_i)$, on the observation $\by$, and compute
the distances, $e_i$, using a flat-earth approximation (any discrepancies will be minimal due to the small
distances between points). That is, the \emph{equirectangular projection}.
This uses Earth's radius $R = 6371000$~m, along with all values converted to \emph{radians}:
$\by^{\mathrm{rad}} = \frac{\pi}{180}\by = \left(\lambda_y, \phi_y\right)$ and
$\bz_i^{\mathrm{rad}} = \frac{\pi}{180}\bz_i = \left(\lambda_{z_i}, \phi_{z_i}\right)$.
\begin{align*}
  a_i &= \left( \lambda_y - \lambda_{z_{i}} \right) \cos\left(0.5\left(\phi_y + \phi_{z_i}\right)\right) \\
  &= \Delta\lambda \cos\left(0.5\left(\phi_y + \phi_{z_i}\right)\right) \\
  b_i &= \phi_y - \phi_{z_i} = \Delta\phi \\
  e_i &= R \sqrt{a^2 + b^2},
\end{align*}
the distance in whatever units $R$ is.
This can of course be vectorised fairly easily:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{distanceFlat} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{z}\hlstd{,} \hlkwc{R} \hlstd{=} \hlnum{6371000}\hlstd{) \{}
    \hlcom{## computes the distance between \{y\} and \{z\}}
    \hlcom{## different R (such as in km) give results in those units}
    \hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{dim}\hlstd{(y))} \hlopt{<} \hlnum{2}\hlstd{)}
        \hlstd{y} \hlkwb{<-} \hlkwd{cbind}\hlstd{(y)}
    \hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{dim}\hlstd{(z))} \hlopt{<} \hlnum{2}\hlstd{)}
        \hlstd{z} \hlkwb{<-} \hlkwd{cbind}\hlstd{(z)}
    \hlkwa{if} \hlstd{(}\hlkwd{ncol}\hlstd{(y)} \hlopt{!=} \hlkwd{ncol}\hlstd{(z)} \hlopt{&} \hlkwd{ncol}\hlstd{(y)} \hlopt{>} \hlnum{1} \hlopt{&} \hlkwd{ncol}\hlstd{(z)} \hlopt{>} \hlnum{1}\hlstd{)}
        \hlkwd{stop}\hlstd{(}\hlstr{"Incorrent dimensions"}\hlstd{)}

    \hlcom{## need to scale from degrees to radians:}
    \hlstd{lam.y} \hlkwb{<-} \hlstd{y[}\hlnum{1}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{lam.z} \hlkwb{<-} \hlstd{z[}\hlnum{1}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{phi.y} \hlkwb{<-} \hlstd{y[}\hlnum{2}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{phi.z} \hlkwb{<-} \hlstd{z[}\hlnum{2}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{R} \hlopt{*} \hlkwd{sqrt}\hlstd{(((lam.y} \hlopt{-} \hlstd{lam.z)} \hlopt{*} \hlkwd{cos}\hlstd{(}\hlnum{0.5} \hlopt{*} \hlstd{(phi.y} \hlopt{+} \hlstd{phi.z)))}\hlopt{^}\hlnum{2} \hlopt{+} \hlstd{(phi.y} \hlopt{-} \hlstd{phi.z)}\hlopt{^}\hlnum{2}\hlstd{)}
\hlstd{\}}
\hlstd{y} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{174.78525}\hlstd{,} \hlopt{-}\hlnum{36.84914}\hlstd{)}
\hlstd{z} \hlkwb{<-} \hlkwd{t}\hlstd{(shape1)}
\hlkwd{distanceFlat}\hlstd{(y, z)}
\end{alltt}
\begin{verbatim}
##  [1] 4149.9430 3773.1680 3672.3494 3561.8636 3377.5161 3190.9290 3044.6800
##  [8] 2750.7017 2535.6988 2240.4274 2008.4752 1878.3004 1771.6265 1404.8933
## [15] 1196.1452 1012.4265  809.3050  604.4278  512.1066  367.1038  163.3630
## [22]  106.1185  340.3363 1066.4919 1653.8565
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Route Distances}

We can also use the equirectangular projection to compute the length of each segment in the route
path, which we can use to determine distance into trip.
We will compute bearings in the next part.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# "from" 1->2, 2->3, 3->4, ..., (n-1)->n}
\hlstd{y} \hlkwb{<-} \hlstd{z[,} \hlopt{-}\hlkwd{ncol}\hlstd{(z)]}
\hlstd{z} \hlkwb{<-} \hlstd{z[,} \hlopt{-}\hlnum{1}\hlstd{]}
\hlstd{di} \hlkwb{<-} \hlkwd{distanceFlat}\hlstd{(y, z)}
\hlstd{shape1}\hlopt{$}\hlstd{distance} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwd{cumsum}\hlstd{(di))}
\hlstd{shape1}\hlopt{$}\hlstd{length} \hlkwb{<-} \hlkwd{c}\hlstd{(di,} \hlnum{NA}\hlstd{)}
\hlstd{shape1[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{,} \hlnum{23}\hlopt{:}\hlnum{25}\hlstd{), ]}
\end{alltt}
\begin{verbatim}
##         lon       lat  distance   length
## 1  174.7985 -36.88493    0.0000 376.7768
## 2  174.7973 -36.88168  376.7768 104.2504
## 3  174.7972 -36.88074  481.0271 263.5338
## 23 174.7818 -36.84780 5801.5484 726.6895
## 24 174.7742 -36.84535 6528.2379 590.9006
## 25 174.7678 -36.84393 7119.1384       NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Well, that was easy.

\subsubsection{Route Bearings}

The next part is a little less simple, as the ``bearing'' changes as you move around the Earth in a
straight line.
Not that it will change much over a few hundred meters, we will use the initial bearing, $\theta^\circ$.
This will be used in the next step when we compute the position given a starting point, bearing, and
a distance traveled. 

Here we compute the initial bearing along segment a segment $\vec{ab}$,
$(\phi_a, \lambda_a)$ to $(\phi_b, \lambda_b)$ (again, in radians not degrees).
Also, $\Delta\lambda = \lambda_b - \lambda_a$.
\begin{align}
  \label{eq:bearing_comp}
  \theta^{\mathrm{rad}} &= 
  \mathrm{atan2}\left(\sin\Delta\lambda \cos\phi_b, 
           \cos\phi_a \sin\phi_b - \sin\phi_a \cos\phi_b \cos\Delta\lambda\right) \\
  \theta^\star &= \frac{180}{\pi}\theta^{\mathrm{rad}} \in \left[-180,180\right) \\
  \theta^\circ &= \left(\theta^\star + 180\right) \mod 360 \in \left[0,360\right)
\end{align}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{bearing} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{a}\hlstd{,} \hlkwc{b}\hlstd{) \{}
    \hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{dim}\hlstd{(a))} \hlopt{<} \hlnum{2}\hlstd{) y} \hlkwb{<-} \hlkwd{cbind}\hlstd{(a)}
    \hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{dim}\hlstd{(b))} \hlopt{<} \hlnum{2}\hlstd{) z} \hlkwb{<-} \hlkwd{cbind}\hlstd{(b)}
    \hlkwa{if} \hlstd{(}\hlkwd{ncol}\hlstd{(a)} \hlopt{!=} \hlkwd{ncol}\hlstd{(b)} \hlopt{&} \hlkwd{ncol}\hlstd{(a)} \hlopt{>} \hlnum{1} \hlopt{&} \hlkwd{ncol}\hlstd{(b)} \hlopt{>} \hlnum{1}\hlstd{)}
        \hlkwd{stop}\hlstd{(}\hlstr{"Incorrent dimensions"}\hlstd{)}

    \hlcom{## convert to radians!!}
    \hlstd{lam.a} \hlkwb{<-} \hlstd{a[}\hlnum{1}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{lam.b} \hlkwb{<-} \hlstd{b[}\hlnum{1}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{phi.a} \hlkwb{<-} \hlstd{a[}\hlnum{2}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{phi.b} \hlkwb{<-} \hlstd{b[}\hlnum{2}\hlstd{, ]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}

    \hlstd{th.rad} \hlkwb{<-} \hlkwd{atan2}\hlstd{(}\hlkwd{sin}\hlstd{(lam.b} \hlopt{-} \hlstd{lam.a)} \hlopt{*} \hlkwd{cos}\hlstd{(phi.b),}
                    \hlkwd{cos}\hlstd{(phi.a)} \hlopt{*} \hlkwd{sin}\hlstd{(phi.b)} \hlopt{-} \hlkwd{sin}\hlstd{(phi.a)} \hlopt{*} \hlkwd{cos}\hlstd{(phi.b)} \hlopt{*} \hlkwd{cos}\hlstd{(lam.b} \hlopt{-} \hlstd{lam.a))}
    \hlstd{(th.rad} \hlopt{*} \hlnum{180} \hlopt{/} \hlstd{pi)} \hlopt{%%} \hlnum{360}
\hlstd{\}}
\hlstd{shape1}\hlopt{$}\hlstd{bearing} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{bearing}\hlstd{(y, z),} \hlnum{NA}\hlstd{)}
\hlkwd{head}\hlstd{(shape1)}
\end{alltt}
\begin{verbatim}
##        lon       lat  distance   length   bearing
## 1 174.7985 -36.88493    0.0000 376.7768 343.68534
## 2 174.7973 -36.88168  376.7768 104.2504 358.04430
## 3 174.7972 -36.88074  481.0271 263.5338 279.76479
## 4 174.7943 -36.88034  744.5610 250.6042 305.63207
## 5 174.7920 -36.87902  995.1652 229.7301  24.23082
## 6 174.7931 -36.87714 1224.8952 165.5958  14.62306
\end{verbatim}
\end{kframe}
\end{knitrout}

That was also nice and easy! Well, only because we didn't have to figure out the formula!


\subsubsection{Coordinates of Distance into Segment}

Previously, we used basic trigonometry to figure out the $(X,Y)$ location mid-segment. That doesn't
apply now that we are moving between GPS coordinates.
Fortunately, someone smart figured out the formula for us.

The GPS coordinates of a particle, $\bz^{\mathrm{rad}} = (\lambda_z, \phi_z)$ 
(in radians, dropping the $i$ subscript for simplicity), that travels a
distance of $d$~m from the point $\bs = (\lambda_s, \phi_s)$ (in radians) at an initial bearing of $\theta^\circ$
is calcualted as follows.
We use the angle in radians, $\theta = \frac{\pi}{180}\theta^\circ$,
and the distance in radians, $\delta = \frac{d}{R}$ ($R$ is the Earth's radius, in the same units
and $d$).
\begin{align*}
  \phi_z &= 
  \sin^{-1}\left(
    \sin\phi_s \cos\delta + \cos\phi_s \sin\delta \cos\theta
  \right) \\
  \lambda_z &=
  \lambda_s + \mathrm{atan2}\left(
    \sin\theta \sin\delta \cos\phi_s,
    \cos\delta - \sin\phi_s \sin\phi_z
  \right)
\end{align*}

Looks simple enough, let's use it. Let's say we are 3000~m into the trip:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{partialSegment} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{theta}\hlstd{,} \hlkwc{d}\hlstd{,} \hlkwc{R} \hlstd{=} \hlnum{6371000}\hlstd{) \{}
    \hlstd{delta} \hlkwb{<-} \hlstd{d} \hlopt{/} \hlstd{R} \hlcom{## for single calculation}
    \hlstd{theta} \hlkwb{<-} \hlstd{theta} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}  \hlcom{## convert to radians}
    \hlstd{phi.s} \hlkwb{<-} \hlstd{x[}\hlnum{2}\hlstd{]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}
    \hlstd{lam.s} \hlkwb{<-} \hlstd{x[}\hlnum{1}\hlstd{]} \hlopt{*} \hlstd{pi} \hlopt{/} \hlnum{180}

    \hlstd{phi.z} \hlkwb{<-} \hlkwd{asin}\hlstd{(}\hlkwd{sin}\hlstd{(phi.s)} \hlopt{*} \hlkwd{cos}\hlstd{(delta)} \hlopt{+} \hlkwd{cos}\hlstd{(phi.s)} \hlopt{*} \hlkwd{sin}\hlstd{(delta)} \hlopt{*} \hlkwd{cos}\hlstd{(theta))}
    \hlstd{lam.z} \hlkwb{<-} \hlstd{lam.s} \hlopt{+} \hlkwd{atan2}\hlstd{(}\hlkwd{sin}\hlstd{(theta)} \hlopt{*} \hlkwd{sin}\hlstd{(delta)} \hlopt{*} \hlkwd{cos}\hlstd{(phi.s),}
                           \hlkwd{cos}\hlstd{(delta)} \hlopt{-} \hlkwd{sin}\hlstd{(phi.s)} \hlopt{*} \hlkwd{sin}\hlstd{(phi.z))}
    \hlkwd{c}\hlstd{(lam.z, phi.z)} \hlopt{*} \hlnum{180} \hlopt{/} \hlstd{pi}
\hlstd{\}}
\hlstd{h} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{shape}\hlstd{) \{}
    \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{<=} \hlnum{0}\hlstd{)} \hlkwd{return}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0}\hlstd{))}
    \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>} \hlkwd{max}\hlstd{(shape}\hlopt{$}\hlstd{distance))} \hlkwd{return}\hlstd{(}\hlkwd{as.numeric}\hlstd{(shape[}\hlkwd{nrow}\hlstd{(shape),} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]))}

    \hlstd{j} \hlkwb{<-} \hlkwd{which.min}\hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>} \hlstd{shape}\hlopt{$}\hlstd{distance)} \hlopt{-} \hlnum{1}
    \hlstd{sj} \hlkwb{<-} \hlstd{shape[j, ]}
    \hlstd{Psi} \hlkwb{<-} \hlstd{sj}\hlopt{$}\hlstd{bearing}
    \hlstd{d} \hlkwb{<-} \hlstd{x[}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{sj}\hlopt{$}\hlstd{distance}

    \hlcom{## only do the calculations if we need to!}
    \hlkwa{if} \hlstd{(d} \hlopt{==} \hlnum{0}\hlstd{)} \hlkwd{return}\hlstd{(}\hlkwd{as.numeric}\hlstd{(sj[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]))}
    \hlkwd{partialSegment}\hlstd{(}\hlkwd{as.numeric}\hlstd{(sj[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]), Psi, d)}
\hlstd{\}}
\hlstd{x} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3000}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlstd{z} \hlkwb{<-} \hlkwd{h}\hlstd{(x, shape1)}
\hlkwd{plotShape}\hlstd{(shapeIDs[}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{], con)}
\hlkwd{points}\hlstd{(shape1}\hlopt{$}\hlstd{lon, shape1}\hlopt{$}\hlstd{lat,} \hlkwc{cex} \hlstd{=} \hlnum{0.4}\hlstd{,} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
\hlkwd{points}\hlstd{(z[}\hlnum{1}\hlstd{], z[}\hlnum{2}\hlstd{],} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/distance_into_trip_calc-1} 

}



\end{knitrout}

Hopefully this will be all we need for the following applications. We also make no assumptions about
location, so it should be transferable between cities, countries, and continents.


\section{Mock GTFS Realtime Data}

The next step is to create some mock data (i.e., bus locations at a sequence of time
points).  In the first few sections, we used equal time differences, so it makes sense to
first apply our model using evenly spaced time points. We will do this in two stages:
\begin{enumerate}
\item 
  using a constant speed function (essentially the same as the previous simulation), and
  
  
\item 
  using the schedule data and fit a smooth polynomial through this, the derivative of
  which will give us scheduled speed.
\end{enumerate}
Both will use the same route as used above.


\subsection{Constant Speed}

We will assume the bus travels at a \emph{constant speed} of 40~km/h $\approx 11$~m/s.
The function $h$ defined at the end of the previous section will be used to convert from (distance,speed)
to GPS coordinates.
We also need to be able to add random ``noise'' to these measurements for the simulation, 
which we will later need to use as a distribution $p(\bv_k)$.

We are going to assume that the variability is equal in all directions, therefore we can simplify everything
to a univariate distribution of ``distances'', each associated with a random bearing $\theta\in[0,180)$ 
(negative distances provide the other half of the circle).
Therefore, we can simulate from:
\begin{equation*}
  \bv = 
  \begin{bmatrix}
    d \\ \theta
  \end{bmatrix},\qquad
  \begin{matrix}
    d\sim \mathcal{N}\left(0,\sigma_v^2\right)\\
    \theta \sim \mathcal{U}\left[0,180\right)
  \end{matrix}.
\end{equation*}
We therefore simply add this to our function, as we know how to add a certain distance to a GPS 
coordinate with initial bearing (\S~2.1.4). Thus,
\begin{equation}
  \label{eq:observation_}
  \by_k = \bY_k + \bv_k,
\end{equation}
where ``addition'' is of a (distance, bearing) to a GPS coordinate.


\subsubsection{Data Generation}

Let's create some mock data:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{t} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{)} \hlopt{*} \hlnum{60}  \hlcom{# time in minutes * 60 = seconds}
\hlstd{n} \hlkwb{<-} \hlkwd{length}\hlstd{(t)}

\hlstd{Xtrue} \hlkwb{<-} \hlkwd{rbind}\hlstd{(t} \hlopt{*} \hlnum{11}\hlstd{,} \hlnum{11}\hlstd{)}
\hlstd{Ytrue} \hlkwb{<-} \hlkwd{apply}\hlstd{(Xtrue,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

\hlstd{v} \hlkwb{<-} \hlkwd{rbind}\hlstd{(}\hlkwd{rnorm}\hlstd{(n,} \hlnum{0}\hlstd{,} \hlnum{50}\hlstd{),} \hlkwd{runif}\hlstd{(n,} \hlnum{0}\hlstd{,} \hlnum{180}\hlstd{))}
\hlstd{y} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlnum{1}\hlopt{:}\hlstd{n,} \hlkwa{function}\hlstd{(}\hlkwc{i}\hlstd{)} \hlkwd{partialSegment}\hlstd{(Ytrue[, i], v[}\hlnum{2}\hlstd{, i], v[}\hlnum{1}\hlstd{, i]))}

\hlstd{thePlot3} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x1}\hlstd{,} \hlkwc{x2}\hlstd{) \{}
    \hlkwd{plotShape}\hlstd{(shapeIDs[}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{], con)}
    \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{missing}\hlstd{(x1))} \hlkwd{points}\hlstd{(x1[}\hlnum{1}\hlstd{, ], x1[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{missing}\hlstd{(x2))} \hlkwd{points}\hlstd{(x2[}\hlnum{1}\hlstd{, ], x2[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
    \hlkwd{points}\hlstd{(Ytrue[}\hlnum{1}\hlstd{, ], Ytrue[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{)}
    \hlkwd{points}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{)}
\hlstd{\}}
\hlkwd{thePlot3}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/constant_speed_mock-1} 

}



\end{knitrout}


\subsubsection{Likelihood}

We need a likelihood for the observation. We will continue on with our assumption of equal distances,
and therefore simply model the distances, $d_k$, between the particles and the observation.
We can just use the function from before (ignoring direction).
For consistency, we will use $\sigma_v = 50$ as in the simulation;
in practice, we should be able to estimate the accuracy either from the GPS model,
or more likely by computing the ``distance from the road'' of GPS observations.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lhood} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{x}\hlstd{,} \hlkwc{shape}\hlstd{)}
    \hlkwd{dnorm}\hlstd{(}\hlkwd{distanceFlat}\hlstd{(y,} \hlkwd{h}\hlstd{(x,} \hlkwc{shape} \hlstd{= shape)),} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{50}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\subsubsection{Simulation}

We'll use the same equations as in \S~1.1 (random acceleration), and the same prior on $x_0$:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## random error on particles:}
\hlstd{pw} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{n}\hlstd{)}
    \hlkwd{rnorm}\hlstd{(n,} \hlnum{0}\hlstd{,} \hlnum{0.05}\hlstd{)}
\hlstd{Delta} \hlkwb{<-} \hlnum{60} \hlcom{## seconds}
\hlstd{A} \hlkwb{<-} \hlkwd{cbind}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{0}\hlstd{),} \hlkwd{c}\hlstd{(Delta,} \hlnum{1}\hlstd{))}
\hlstd{G} \hlkwb{<-} \hlkwd{rbind}\hlstd{(Delta}\hlopt{^}\hlnum{2}\hlopt{/}\hlnum{2}\hlstd{, Delta)}
\hlstd{fn} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{w}\hlstd{)}
    \hlkwd{structure}\hlstd{(A} \hlopt{%*%} \hlstd{x} \hlopt{+} \hlstd{G} \hlopt{%*%} \hlstd{w,} \hlkwc{.Dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"distance"}\hlstd{,} \hlstr{"speed"}\hlstd{),} \hlkwa{NULL}\hlstd{))}

\hlstd{N} \hlkwb{<-} \hlnum{300} \hlcom{## particles}
\hlstd{x0} \hlkwb{<-} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(N,} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{50}\hlstd{))))} \hlcom{# should really just use rbind(0, rnorm()) ...}

\hlstd{x1hat} \hlkwb{<-} \hlkwd{fn}\hlstd{(x0,} \hlkwd{pw}\hlstd{(N))}
\hlstd{hx1hat} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

\hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[,} \hlnum{1}\hlstd{], xi, shape1))}
\hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
\hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
\hlstd{x1} \hlkwb{<-} \hlstd{x1hat[, ii]}
\hlstd{hx1} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

\hlkwd{thePlot3}\hlstd{(hx1hat, hx1)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/simulation_init-1} 

}



\end{knitrout}

And, yes, now all of them!

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{3}\hlstd{))}
\hlstd{xx} \hlkwb{<-} \hlstd{x1}
\hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(t)}
\hlstd{xxhat.hist} \hlkwb{<-} \hlstd{xx.hist} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{, N, M))}
\hlstd{xxhat.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1hat}
\hlstd{xx.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1}
\hlkwd{system.time}\hlstd{(\{}
    \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{2}\hlopt{:}\hlstd{M) \{}
        \hlstd{xxhat.hist[,,i]} \hlkwb{<-} \hlstd{xxhat} \hlkwb{<-} \hlkwd{fn}\hlstd{(xx,} \hlkwd{pw}\hlstd{(N))}
        \hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[, i], xi, shape1))}
        \hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
        \hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
        \hlstd{xx.hist[,,i]} \hlkwb{<-} \hlstd{xx} \hlkwb{<-} \hlstd{xxhat[, ii]}
        \hlstd{hxxhat} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

        \hlstd{hxx} \hlkwb{<-} \hlkwd{apply}\hlstd{(xx,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}
        \hlkwd{thePlot3}\hlstd{(hxxhat, hxx)}
    \hlstd{\}}
\hlstd{\})}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/simulation__all-1} 

}


\begin{kframe}\begin{verbatim}
##    user  system elapsed 
##   1.334   0.000   1.335
\end{verbatim}
\begin{alltt}
\hlkwd{rowMeans}\hlstd{(xx)}
\end{alltt}
\begin{verbatim}
##   distance      speed 
## 6603.07022   11.73706
\end{verbatim}
\end{kframe}
\end{knitrout}

So, about 0.15~s to analyse one data point. In R. Without any thoughts having gone into making
things efficient.


\subsubsection{Variable Speed and Irregular Time Observations}

This is easy to generalise, as we make no assumption about the frequency of observations;
we fixed $\Delta = 60$~s in the above example, but this could easily be adjusted for each observation.

To get starting, we are simply going to use the schedule information for a trip as the ``observed
data'', and see how the model performs.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{all.trips} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(con,} \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT DISTINCT trip_id FROM trips WHERE shape_id='%s'"}\hlstd{, shapeIDs[}\hlnum{1}\hlstd{,}\hlnum{1}\hlstd{]))}
\hlstd{trip1} \hlkwb{<-} \hlstd{all.trips[}\hlnum{1}\hlstd{,}\hlnum{1}\hlstd{]}
\hlstd{sched1} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(}
    \hlstd{con,}
    \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT st.arrival_time AS arrive, st.departure_time AS depart, st.stop_id, 
                    s.stop_lat, s.stop_lon, st.shape_dist_traveled AS distance
             FROM stop_times AS st, stops AS s 
             WHERE trip_id='%s' AND st.stop_id=s.stop_id"}\hlstd{, trip1))}
\hlkwd{head}\hlstd{(sched1)}
\end{alltt}
\begin{verbatim}
##     arrive   depart stop_id  stop_lat stop_lon distance
## 1     <NA> 06:15:00    6072 -36.88493 174.7985       NA
## 2 06:15:00 06:15:00    6726 -36.88168 174.7973       NA
## 3 06:16:00 06:16:00    5084 -36.88074 174.7972       NA
## 4 06:16:00 06:16:00    5085 -36.88034 174.7943       NA
## 5 06:16:00 06:16:00    2152 -36.87902 174.7920       NA
## 6 06:17:00 06:17:00    2153 -36.87714 174.7931       NA
\end{verbatim}
\end{kframe}
\end{knitrout}

We don't actually need the \emph{distance} column right now---this will be used later when computing 
which stop interval the bus is in. What we do need is to condense it down into unique time observations
(currently, there are several stops at each ``minute'').
We will take the first of each, and take the departure time (or arrival if its missing);
we will also convert times into seconds since the route began.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(lubridate)}
\hlstd{sched1}\hlopt{$}\hlstd{time} \hlkwb{<-} \hlkwd{hms}\hlstd{(}\hlkwd{ifelse}\hlstd{(}\hlkwd{is.na}\hlstd{(sched1}\hlopt{$}\hlstd{depart), sched1}\hlopt{$}\hlstd{arrive, sched1}\hlopt{$}\hlstd{depart))}
\hlstd{sched1}\hlopt{$}\hlstd{time_seconds} \hlkwb{<-} \hlstd{(}\hlkwd{hour}\hlstd{(sched1}\hlopt{$}\hlstd{time)} \hlopt{*} \hlnum{60} \hlopt{+} \hlkwd{minute}\hlstd{(sched1}\hlopt{$}\hlstd{time))} \hlopt{*} \hlnum{60}
\hlstd{sched1}\hlopt{$}\hlstd{time} \hlkwb{<-} \hlstd{sched1}\hlopt{$}\hlstd{time_seconds} \hlopt{-} \hlkwd{min}\hlstd{(sched1}\hlopt{$}\hlstd{time_seconds)}
\hlstd{data} \hlkwb{<-} \hlkwd{do.call}\hlstd{(}
    \hlstd{rbind,}
    \hlkwd{tapply}\hlstd{(}\hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(sched1), sched1}\hlopt{$}\hlstd{time,}
           \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) sched1[x[}\hlnum{1}\hlstd{],} \hlkwd{c}\hlstd{(}\hlstr{"time"}\hlstd{,} \hlstr{"stop_id"}\hlstd{,} \hlstr{"stop_lat"}\hlstd{,} \hlstr{"stop_lon"}\hlstd{), ]))}
\hlstd{data[}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{, ]}
\end{alltt}
\begin{verbatim}
##     time stop_id  stop_lat stop_lon
## 0      0    6072 -36.88493 174.7985
## 60    60    5084 -36.88074 174.7972
## 120  120    2153 -36.87714 174.7931
\end{verbatim}
\begin{alltt}
\hlstd{t} \hlkwb{<-} \hlstd{data}\hlopt{$}\hlstd{time}
\hlstd{y} \hlkwb{<-} \hlkwd{rbind}\hlstd{(data}\hlopt{$}\hlstd{stop_lon[}\hlopt{-}\hlnum{1}\hlstd{], data}\hlopt{$}\hlstd{stop_lat[}\hlopt{-}\hlnum{1}\hlstd{])}
\end{alltt}
\end{kframe}
\end{knitrout}

And now we just apply the simulation, but allow for differing $\Delta$:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## random error on particles:}
\hlstd{pw} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{n}\hlstd{)}
    \hlkwd{rnorm}\hlstd{(n,} \hlnum{0}\hlstd{,} \hlnum{0.03}\hlstd{)}
\hlstd{Delta} \hlkwb{<-} \hlkwd{diff}\hlstd{(t)} \hlcom{## seconds}
\hlstd{A} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{d}\hlstd{)} \hlkwd{cbind}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{0}\hlstd{),} \hlkwd{c}\hlstd{(d,} \hlnum{1}\hlstd{))}
\hlstd{G} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{d}\hlstd{)} \hlkwd{rbind}\hlstd{(d}\hlopt{^}\hlnum{2}\hlopt{/}\hlnum{2}\hlstd{, d)}
\hlstd{fn} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{u}\hlstd{,} \hlkwc{w}\hlstd{)}  \hlcom{## x: [distance, velocity]; u: [delta]; w: [error]}
    \hlkwd{structure}\hlstd{(}\hlkwd{A}\hlstd{(u)} \hlopt{%*%} \hlstd{x} \hlopt{+} \hlkwd{G}\hlstd{(u)} \hlopt{%*%} \hlstd{w,} \hlkwc{.Dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"distance"}\hlstd{,} \hlstr{"speed"}\hlstd{),} \hlkwa{NULL}\hlstd{))}

\hlstd{thePlot4} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x1}\hlstd{,} \hlkwc{x2}\hlstd{) \{}
    \hlkwd{plotShape}\hlstd{(shapeIDs[}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{], con)}
    \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{missing}\hlstd{(x1))} \hlkwd{points}\hlstd{(x1[}\hlnum{1}\hlstd{, ], x1[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{missing}\hlstd{(x2))} \hlkwd{points}\hlstd{(x2[}\hlnum{1}\hlstd{, ], x2[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
    \hlcom{#points(Ytrue[1, ], Ytrue[2, ], pch = 19, col = "red", cex = 0.5)}
    \hlkwd{points}\hlstd{(y[}\hlnum{1}\hlstd{, ], y[}\hlnum{2}\hlstd{, ],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{)}
\hlstd{\}}

\hlstd{lhood2} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{x}\hlstd{,} \hlkwc{shape}\hlstd{)}
    \hlkwd{dnorm}\hlstd{(}\hlkwd{distanceFlat}\hlstd{(y,} \hlkwd{h}\hlstd{(x,} \hlkwc{shape} \hlstd{= shape)),} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{50}\hlstd{)} \hlopt{*} \hlkwd{ifelse}\hlstd{(x[}\hlnum{2}\hlstd{]} \hlopt{<=} \hlnum{0}\hlstd{,} \hlnum{0.000001}\hlstd{,} \hlnum{1}\hlstd{)}

\hlstd{N} \hlkwb{<-} \hlnum{500} \hlcom{## particles}
\hlstd{x0} \hlkwb{<-} \hlkwd{t}\hlstd{(}\hlkwd{rmvnorm}\hlstd{(N,} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{diag}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{50}\hlstd{))))} \hlcom{# should really just use rbind(0, rnorm()) ...}

\hlstd{x1hat} \hlkwb{<-} \hlkwd{fn}\hlstd{(x0, Delta[}\hlnum{1}\hlstd{],} \hlkwd{pw}\hlstd{(N))}
\hlstd{hx1hat} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

\hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1hat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood2}\hlstd{(y[,} \hlnum{1}\hlstd{], xi, shape1))}
\hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
\hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
\hlstd{x1} \hlkwb{<-} \hlstd{x1hat[, ii]}
\hlstd{hx1} \hlkwb{<-} \hlkwd{apply}\hlstd{(x1,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

\hlkwd{thePlot4}\hlstd{(hx1hat, hx1)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/simulation_init_sched-1} 

}



\end{knitrout}

And, yes, now all of them!

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{3}\hlstd{))}
\hlstd{xx} \hlkwb{<-} \hlstd{x1}
\hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(Delta)}
\hlstd{xxhat.hist} \hlkwb{<-} \hlstd{xx.hist} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{, N, M))}
\hlstd{xxhat.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1hat}
\hlstd{xx.hist[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x1}
\hlkwd{system.time}\hlstd{(\{}
    \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{2}\hlopt{:}\hlstd{M) \{}
        \hlstd{xxhat.hist[,,i]} \hlkwb{<-} \hlstd{xxhat} \hlkwb{<-} \hlkwd{fn}\hlstd{(xx, Delta[i],} \hlkwd{pw}\hlstd{(N))}
        \hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood2}\hlstd{(y[, i], xi, shape1))}
        \hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
        \hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
        \hlstd{xx.hist[,,i]} \hlkwb{<-} \hlstd{xx} \hlkwb{<-} \hlstd{xxhat[, ii]}
        \hlstd{hxxhat} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}

        \hlstd{hxx} \hlkwb{<-} \hlkwd{apply}\hlstd{(xx,} \hlnum{2}\hlstd{, h,} \hlkwc{shape} \hlstd{= shape1)}
        \hlkwd{thePlot4}\hlstd{(hxxhat, hxx)}
    \hlstd{\}}
\hlstd{\})}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/simulation_sched_all-1} 

}




{\centering \includegraphics[width=\maxwidth]{figure/simulation_sched_all-2} 

}




{\centering \includegraphics[width=\maxwidth]{figure/simulation_sched_all-3} 

}




{\centering \includegraphics[width=\maxwidth]{figure/simulation_sched_all-4} 

}




{\centering \includegraphics[width=\maxwidth]{figure/simulation_sched_all-5} 

}


\begin{kframe}\begin{verbatim}
##    user  system elapsed 
##   3.932   0.008   3.943
\end{verbatim}
\begin{alltt}
\hlkwd{rowMeans}\hlstd{(xx)}
\end{alltt}
\begin{verbatim}
##    distance       speed 
## 7530.581815    6.673048
\end{verbatim}
\end{kframe}
\end{knitrout}

How about speed over  time?
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{speedhat.hist} \hlkwb{<-} \hlstd{xxhat.hist[}\hlnum{2}\hlstd{,,]}
\hlstd{speed.hist} \hlkwb{<-} \hlstd{xx.hist[}\hlnum{2}\hlstd{,,]}
\hlkwd{plot}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{xlim} \hlstd{=} \hlkwd{range}\hlstd{(t),} \hlkwc{ylim} \hlstd{=} \hlkwd{range}\hlstd{(speed.hist, speedhat.hist),}
     \hlkwc{xlab} \hlstd{=} \hlstr{"Time (s)"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Speed (m/s)"}\hlstd{)}
\hlkwd{abline}\hlstd{(}\hlkwc{h} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{3}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{M) \{}
    \hlkwd{points}\hlstd{(}\hlkwd{rep}\hlstd{(t[i}\hlopt{+}\hlnum{1}\hlstd{], N), speedhat.hist[, i],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{)}
    \hlkwd{points}\hlstd{(}\hlkwd{rep}\hlstd{(t[i}\hlopt{+}\hlnum{1}\hlstd{], N), speed.hist[, i],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-2-1} 

}



\end{knitrout}

From that, it looks like we need to put a positive-speed constraint on the proposal distribution;
however, we also need to change the way we view \emph{speed}: it will not be an unknown, fairly
constant variable. Instead, we will use as much information as is avaialble to us to esimate the
speed along each segment of road.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{speedhat} \hlkwb{<-} \hlkwd{as.numeric}\hlstd{(speedhat.hist)}
\hlstd{speed} \hlkwb{<-} \hlkwd{as.numeric}\hlstd{(speed.hist)}
\hlstd{disthat} \hlkwb{<-} \hlkwd{as.numeric}\hlstd{(xxhat.hist[}\hlnum{1}\hlstd{,,])}
\hlstd{dist} \hlkwb{<-} \hlkwd{as.numeric}\hlstd{(xx.hist[}\hlnum{1}\hlstd{,,])}

\hlkwd{plot}\hlstd{(disthat, speedhat,} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{,}
     \hlkwc{xlim} \hlstd{=} \hlkwd{range}\hlstd{(dist, disthat),} \hlkwc{ylim} \hlstd{=} \hlkwd{range}\hlstd{(speed, speedhat),}
     \hlkwc{xlab} \hlstd{=} \hlstr{"Distance (m)"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Speed (m/s"}\hlstd{)}
\hlkwd{points}\hlstd{(dist, speed,} \hlkwc{pch} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-3-1} 

}



\end{knitrout}



\section{MBTA GTFS Realtime Feed}

Thankfully, we can get some data! The connection to the database is:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mbta} \hlkwb{<-} \hlkwd{dbConnect}\hlstd{(}\hlkwd{SQLite}\hlstd{(),} \hlstr{"mbta_gtfsrt.db"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

And the historical data can be sorted through nicely:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hist} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(}
    \hlstd{mbta,} \hlstr{"SELECT v.trip_id, t.shape_id, COUNT(v.trip_id) AS n
           FROM vehicle_positions AS v, 
                trips AS t, routes AS r
           WHERE v.trip_id=t.trip_id
             AND t.route_id=r.route_id
             AND r.route_type=3
           GROUP BY v.trip_id ORDER BY n DESC"}\hlstd{)}
\hlkwd{head}\hlstd{(hist)}
\end{alltt}
\begin{verbatim}
##    trip_id shape_id    n
## 1 27638244  7420013 2399
## 2 27638190  7420013 2205
## 3 27508685  5530028 1393
## 4 27936496  4490021 1275
## 5 27937019  4590008 1211
## 6 27501654   660056 1202
\end{verbatim}
\end{kframe}
\end{knitrout}

So, trip \verb+27638244+ looks pretty popular. We'll get some useful information for that.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tID} \hlkwb{<-} \hlstd{hist[}\hlnum{1}\hlstd{,} \hlstr{"trip_id"}\hlstd{]}
\hlstd{sID} \hlkwb{<-} \hlstd{hist[}\hlnum{1}\hlstd{,} \hlstr{"shape_id"}\hlstd{]}
\hlkwd{plotShape}\hlstd{(sID, mbta)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/trip_route_info-1} 

}



\end{knitrout}


\subsection{Data Sorting}

We've first got to sort through the data. We will start at the beginning (the first trip) and work
our way through---hopefully we will be able to start generating priors and stuff!

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Get all days}
\hlstd{all.dates} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(}
    \hlstd{mbta,}
    \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT DISTINCT trip_start_date FROM vehicle_positions WHERE trip_id='%s'"}\hlstd{,}
            \hlstd{tID))}
\hlstd{(dates} \hlkwb{<-} \hlstd{all.dates}\hlopt{$}\hlstd{trip_start_date)}
\end{alltt}
\begin{verbatim}
## [1] "20150817" "20150820" "20150824" "20150825" "20150826" "20150827"
## [7] "20150831" "20150901" "20150903"
\end{verbatim}
\end{kframe}
\end{knitrout}

We now need a function to obtain all of the necessary data for a trip on a given day:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{getTripData} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{date}\hlstd{,} \hlkwc{id}\hlstd{,} \hlkwc{conn} \hlstd{= con) \{}
    \hlstd{d} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(conn,}
                    \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT position_latitude AS lat, position_longitude AS lon,
                                    timestamp AS time
                             FROM vehicle_positions
                             WHERE trip_id='%s' AND trip_start_date='%s'
                             ORDER BY timestamp"}\hlstd{, id, date))}
    \hlkwd{attr}\hlstd{(d,} \hlstr{"date"}\hlstd{)} \hlkwb{<-} \hlstd{date}
    \hlkwd{attr}\hlstd{(d,} \hlstr{"trip_id"}\hlstd{)} \hlkwb{<-} \hlstd{id}
    \hlkwd{class}\hlstd{(d)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"triphistory"}\hlstd{,} \hlkwd{class}\hlstd{(d))}
    \hlstd{d}
\hlstd{\}}
\hlstd{print.triphistory} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{) \{}
    \hlkwd{print.data.frame}\hlstd{(x)}
    \hlkwd{cat}\hlstd{(}\hlstr{"\textbackslash{}n"}\hlstd{)}
    \hlkwd{print}\hlstd{(}\hlkwd{structure}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{attr}\hlstd{(x,} \hlstr{"date"}\hlstd{),} \hlkwd{attr}\hlstd{(x,} \hlstr{"trip_id"}\hlstd{)),} \hlkwc{.Names} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"date"}\hlstd{,} \hlstr{"trip_id"}\hlstd{)))}
\hlstd{\}}
\hlstd{points.triphistory} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{) \{}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{lon, x}\hlopt{$}\hlstd{lat,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

So, on the first day:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{day1} \hlkwb{<-} \hlkwd{getTripData}\hlstd{(dates[}\hlnum{1}\hlstd{], tID, mbta)}
\hlkwd{head}\hlstd{(day1)}
\end{alltt}
\begin{verbatim}
##        lat       lon       time
## 1 42.35349 -71.05190 1439817349
## 2 42.35273 -71.05531 1439817410
## 3 42.35183 -71.05594 1439817440
## 4 42.35192 -71.05589 1439817501
## 5 42.35261 -71.05546 1439817561
## 6 42.35127 -71.04459 1439817719
## 
##       date    trip_id 
## "20150817" "27638244"
\end{verbatim}
\begin{alltt}
\hlstd{tripShape} \hlkwb{<-} \hlkwd{plotShape}\hlstd{(sID, mbta)}
\hlkwd{points}\hlstd{(day1)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/first_day-1} 

}



\end{knitrout}

So, it's obvious that some points don't belong to the trip---they are of where the bus went
before/after it started/finished (we won't worry about them for now).

\subsection{A Particle Filter Modelling Function}

Previously we've just copy+pasted the necessary code. Now we'll make a function to do it moreorless properly.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{particleFilter} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{data}\hlstd{,} \hlkwc{shape}\hlstd{,}
                           \hlkwc{N} \hlstd{=} \hlnum{200}\hlstd{,}
                           \hlkwc{x0} \hlstd{=} \hlkwd{rbind}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwd{rlnorm}\hlstd{(N,} \hlnum{0}\hlstd{,} \hlnum{2}\hlstd{)),}
                           \hlkwc{GPS.error} \hlstd{=} \hlnum{20}\hlstd{,}
                           \hlkwc{sig.e} \hlstd{=} \hlnum{0.03}\hlstd{,}
                           \hlkwc{...}\hlstd{) \{}
    \hlcom{## Sort out the shape information (using previously defined functions)}
    \hlstd{z} \hlkwb{<-} \hlkwd{t}\hlstd{(shape)}
    \hlstd{di} \hlkwb{<-} \hlkwd{distanceFlat}\hlstd{(z[,} \hlopt{-}\hlkwd{ncol}\hlstd{(z)], z[,} \hlopt{-}\hlnum{1}\hlstd{])}
    \hlstd{shape}\hlopt{$}\hlstd{distance} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwd{cumsum}\hlstd{(di))}
    \hlstd{shape}\hlopt{$}\hlstd{length} \hlkwb{<-} \hlkwd{c}\hlstd{(di,} \hlnum{NA}\hlstd{)}
    \hlstd{shape}\hlopt{$}\hlstd{bearing} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{bearing}\hlstd{(z[,} \hlopt{-}\hlkwd{ncol}\hlstd{(z)], z[,} \hlopt{-}\hlnum{1}\hlstd{]),} \hlnum{NA}\hlstd{)}
    \hlstd{shape} \hlkwb{<-} \hlstd{shape[shape}\hlopt{$}\hlstd{length} \hlopt{>} \hlnum{0} \hlopt{|} \hlkwd{is.na}\hlstd{(shape}\hlopt{$}\hlstd{length), ]}

    \hlcom{## Preparation (redefining all functions):}
    \hlstd{h} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
        \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{<=} \hlnum{0}\hlstd{)} \hlkwd{return}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0}\hlstd{))}
        \hlkwa{if} \hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>} \hlkwd{max}\hlstd{(shape}\hlopt{$}\hlstd{distance))} \hlkwd{return}\hlstd{(}\hlkwd{as.numeric}\hlstd{(shape[}\hlkwd{nrow}\hlstd{(shape),} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]))}
        \hlstd{j} \hlkwb{<-} \hlkwd{which.min}\hlstd{(x[}\hlnum{1}\hlstd{]} \hlopt{>} \hlstd{shape}\hlopt{$}\hlstd{distance)} \hlopt{-} \hlnum{1}
        \hlstd{sj} \hlkwb{<-} \hlstd{shape[j, ]}
        \hlstd{Psi} \hlkwb{<-} \hlstd{sj}\hlopt{$}\hlstd{bearing}
        \hlstd{d} \hlkwb{<-} \hlstd{x[}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{sj}\hlopt{$}\hlstd{distance}

        \hlcom{## only do the calculations if we need to!}
        \hlkwa{if} \hlstd{(d} \hlopt{==} \hlnum{0}\hlstd{)} \hlkwd{return}\hlstd{(}\hlkwd{as.numeric}\hlstd{(sj[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]))}
        \hlkwd{partialSegment}\hlstd{(}\hlkwd{as.numeric}\hlstd{(sj[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]), Psi, d)}
    \hlstd{\}}
    \hlcom{## The likelihood:}
    \hlstd{lhood} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{y}\hlstd{,} \hlkwc{x}\hlstd{)}
        \hlkwd{dnorm}\hlstd{(}\hlkwd{distanceFlat}\hlstd{(y,} \hlkwd{h}\hlstd{(x)),} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{= GPS.error)} \hlopt{*}
            \hlkwd{ifelse}\hlstd{(x[}\hlnum{2}\hlstd{]} \hlopt{<=} \hlnum{0}\hlstd{,} \hlnum{0.000001}\hlstd{,} \hlnum{1}\hlstd{)}
    \hlcom{## The random component:}
    \hlstd{pw} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{n}\hlstd{)}
        \hlkwd{rnorm}\hlstd{(n,} \hlnum{0}\hlstd{, sig.e)}

    \hlcom{## The formal model ... will definitely change!!!}
    \hlstd{A} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{d}\hlstd{)} \hlkwd{cbind}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{0}\hlstd{),} \hlkwd{c}\hlstd{(d,} \hlnum{1}\hlstd{))}
    \hlstd{G} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{d}\hlstd{)} \hlkwd{rbind}\hlstd{(d}\hlopt{^}\hlnum{2}\hlopt{/}\hlnum{2}\hlstd{, d)}
    \hlstd{fn} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{u}\hlstd{,} \hlkwc{w}\hlstd{)} \hlcom{## x: [distance, velocity]; u: [delta]; w: [error]}
        \hlkwd{structure}\hlstd{(}\hlkwd{A}\hlstd{(u)} \hlopt{%*%} \hlstd{x} \hlopt{+} \hlkwd{G}\hlstd{(u)} \hlopt{%*%} \hlstd{w,}
                  \hlkwc{.Dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"distance"}\hlstd{,} \hlstr{"speed"}\hlstd{),} \hlkwa{NULL}\hlstd{))}

    \hlcom{## Data prep:}
    \hlstd{y} \hlkwb{<-} \hlkwd{rbind}\hlstd{(data}\hlopt{$}\hlstd{lon, data}\hlopt{$}\hlstd{lat)}
    \hlstd{t} \hlkwb{<-} \hlstd{data}\hlopt{$}\hlstd{time}
    \hlstd{Delta} \hlkwb{<-} \hlkwd{diff}\hlstd{(t)}
    \hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(Delta)}  \hlcom{## the number of "true" observations...?}

    \hlcom{## Matrix prep:}
    \hlstd{hx} \hlkwb{<-} \hlstd{hxhat} \hlkwb{<-} \hlstd{xxhat} \hlkwb{<-} \hlstd{xx} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{, N, M} \hlopt{+} \hlnum{1}\hlstd{))}

    \hlcom{## Initialise:}
    \hlstd{xx[,,}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{x0}

    \hlcom{## run the simulations}
    \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{M) \{}
        \hlstd{xxhat[,,i}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlkwd{fn}\hlstd{(xx[,,i], Delta[i],} \hlkwd{pw}\hlstd{(N))}
        \hlstd{weights} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat[,,i}\hlopt{+}\hlnum{1}\hlstd{],} \hlnum{2}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{xi}\hlstd{)} \hlkwd{lhood}\hlstd{(y[,i}\hlopt{+}\hlnum{1}\hlstd{], xi))}
        \hlstd{qi} \hlkwb{<-} \hlstd{weights} \hlopt{/} \hlkwd{sum}\hlstd{(weights)}
        \hlkwa{if} \hlstd{(}\hlkwd{any}\hlstd{(}\hlkwd{is.na}\hlstd{(qi)))}
            \hlstd{qi} \hlkwb{<-} \hlkwa{NULL}

        \hlstd{ii} \hlkwb{<-} \hlkwd{sample}\hlstd{(N, N,} \hlnum{TRUE}\hlstd{, qi)}
        \hlstd{xx[,,i}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{xxhat[,ii,i}\hlopt{+}\hlnum{1}\hlstd{]}

        \hlstd{hxhat[,,i}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlkwd{apply}\hlstd{(xxhat[,,i}\hlopt{+}\hlnum{1}\hlstd{],} \hlnum{2}\hlstd{, h)}
        \hlstd{hx[,,i}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlkwd{apply}\hlstd{(xx[,,i}\hlopt{+}\hlnum{1}\hlstd{],} \hlnum{2}\hlstd{, h)}
    \hlstd{\}}

    \hlstd{res} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{Xhat} \hlstd{= xxhat,}
                \hlkwc{X} \hlstd{= xx,}
                \hlkwc{HXhat} \hlstd{= hxhat,}
                \hlkwc{HX} \hlstd{= hx,}
                \hlkwc{y} \hlstd{= y,} \hlkwc{t} \hlstd{= t,} \hlkwc{M} \hlstd{= M,} \hlkwc{N} \hlstd{= N)}
    \hlkwd{class}\hlstd{(res)} \hlkwb{<-} \hlstr{"pf.fit"}

    \hlstd{res}
\hlstd{\}}

\hlstd{plot.pf.fit} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{shape.id}\hlstd{,} \hlkwc{obs} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{conn} \hlstd{= con) \{}
    \hlkwd{plotShape}\hlstd{(sID, conn)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{HXhat[}\hlnum{1}\hlstd{,,obs], x}\hlopt{$}\hlstd{HXhat[}\hlnum{2}\hlstd{,,obs],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{HX[}\hlnum{1}\hlstd{,,obs], x}\hlopt{$}\hlstd{HX[}\hlnum{2}\hlstd{,,obs],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{y[}\hlnum{1}\hlstd{,obs], x}\hlopt{$}\hlstd{y[}\hlnum{2}\hlstd{,obs],} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.4}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Modelling the First Day}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## by manual inspection, filter only observations that occur on the route:}
\hlstd{day1onroute} \hlkwb{<-} \hlstd{day1[}\hlnum{5}\hlopt{:}\hlnum{17}\hlstd{, ]}
\hlstd{day1.results} \hlkwb{<-} \hlkwd{particleFilter}\hlstd{(day1onroute, tripShape)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{2}\hlstd{))}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{day1.results}\hlopt{$}\hlstd{M)}
    \hlkwd{plot}\hlstd{(day1.results, sID, i}\hlopt{+}\hlnum{1}\hlstd{, mbta)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/plot_first_day-1} 

}




{\centering \includegraphics[width=\maxwidth]{figure/plot_first_day-2} 

}



\end{knitrout}

Clearly, the randomness isn't corrently being modelled---but this makes sense! We are using a
Newtonian dynamics model, but that doesn't really apply to a bus that is stopping and starting at
bus stops! We should be taking into account
\begin{enumerate}
\item the (typical) time taken to travel from stop $i$ to stop $i+k$, and
\item the dwell time at stops $i,i+1,\ldots,i+k-1$.
\end{enumerate}


\subsection{Remaining Days}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{2}\hlstd{))}

\hlstd{days} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlnum{2} \hlopt{:}\hlnum{9}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{i}\hlstd{)} \hlkwd{getTripData}\hlstd{(dates[i], tID, mbta))}
\hlkwd{invisible}\hlstd{(}\hlkwd{lapply}\hlstd{(days,} \hlkwa{function}\hlstd{(}\hlkwc{day}\hlstd{) \{}
    \hlkwd{plotShape}\hlstd{(sID, mbta)}
    \hlkwd{points}\hlstd{(day)}
\hlstd{\}))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.8\textwidth]{figure/days_data-1} 

}



\end{knitrout}

It looks like the ``trip ID'' being reported isn't updating correctly.
The best way around this would be to instead of ``block ID'' and decide for ourselves which trip the
bus is on.
However, the current state of the Auckland GTFS doesn't suppy block IDs to routes, so its difficult
(if not impossible) to obtain this information. 

If we were, however, to break away from our Newtonian physics based model, and instead use some
prior knowledge about speed at a given distance into a trip, we should be able to make use of the
``half'' data sets.



\section{Block and Trips}

From the MBTA feed we can get block information, so:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{getShape} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{id}\hlstd{,} \hlkwc{conn}\hlstd{,} \hlkwc{include.id} \hlstd{=} \hlnum{FALSE}\hlstd{) \{}
    \hlstd{sh} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(conn,}
                     \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT shape_pt_lon AS lon, shape_pt_lat AS lat
                              FROM shapes WHERE shape_id='%s'"}\hlstd{, id))}
    \hlkwa{if} \hlstd{(include.id)}
        \hlstd{sh}\hlopt{$}\hlstd{shape_id} \hlkwb{<-} \hlstd{id}

    \hlkwd{class}\hlstd{(sh)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"gtfs.shape"}\hlstd{,} \hlkwd{class}\hlstd{(sh))}
    \hlstd{sh}
\hlstd{\}}
\hlstd{plot.gtfs.shape} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{add} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{...}\hlstd{) \{}
    \hlkwa{if} \hlstd{(add)}
        \hlkwd{lines}\hlstd{(x}\hlopt{$}\hlstd{lon, x}\hlopt{$}\hlstd{lat, ...)}
    \hlkwa{else}
        \hlkwd{plot}\hlstd{(x}\hlopt{$}\hlstd{lon, x}\hlopt{$}\hlstd{lat,} \hlkwc{type} \hlstd{=} \hlstr{"l"}\hlstd{,} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
             \hlkwc{xlab} \hlstd{=} \hlstr{"Longitude"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Latitude"}\hlstd{, ...)}

    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{lon[}\hlnum{1}\hlstd{], x}\hlopt{$}\hlstd{lat[}\hlnum{1}\hlstd{],} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{)}
\hlstd{\}}

\hlstd{getBlock} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{id}\hlstd{,} \hlkwc{conn}\hlstd{) \{}
    \hlstd{blockInfo} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(}
        \hlstd{conn,}
        \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT block_id, trip_id, route_id, shape_id
                 FROM trips WHERE block_id='%s'"}\hlstd{, bID))}

    \hlstd{blockShapes} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwd{unique}\hlstd{(blockInfo}\hlopt{$}\hlstd{shape_id),}
                          \hlkwa{function}\hlstd{(}\hlkwc{id}\hlstd{)} \hlkwd{getShape}\hlstd{(id, conn,} \hlkwc{include.id} \hlstd{=} \hlnum{TRUE}\hlstd{))}
    \hlkwd{names}\hlstd{(blockShapes)} \hlkwb{<-} \hlkwd{unique}\hlstd{(blockInfo}\hlopt{$}\hlstd{shape_id)}
    \hlkwd{class}\hlstd{(blockShapes)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"gtfs.block.shapes"}\hlstd{)}

    \hlstd{fullPath} \hlkwb{<-} \hlkwd{do.call}\hlstd{(rbind, blockShapes[blockInfo}\hlopt{$}\hlstd{shape_id])}
    \hlstd{blockPath} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{lon} \hlstd{= fullPath}\hlopt{$}\hlstd{lon,} \hlkwc{lat} \hlstd{= fullPath}\hlopt{$}\hlstd{lat)}
    \hlkwd{class}\hlstd{(blockPath)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"gtfs.shape"}\hlstd{,} \hlkwd{class}\hlstd{(blockPath))}

    \hlstd{out} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{trips} \hlstd{= blockInfo,}
                \hlkwc{shapes} \hlstd{= blockShapes,}
                \hlkwc{path} \hlstd{= blockPath)}

    \hlkwd{class}\hlstd{(out)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"gtfs.block"}\hlstd{)}
    \hlstd{out}
\hlstd{\}}
\hlstd{print.gtfs.block} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{) \{}
    \hlkwd{print}\hlstd{(x}\hlopt{$}\hlstd{trips)}
\hlstd{\}}
\hlstd{head.gtfs.block} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{n} \hlstd{=} \hlnum{6}\hlstd{,} \hlkwc{...}\hlstd{)}
    \hlkwd{head}\hlstd{(x}\hlopt{$}\hlstd{trips, n, ...)}
\hlstd{plot.gtfs.block} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{)}
    \hlkwd{plot}\hlstd{(x}\hlopt{$}\hlstd{shapes)}
\hlstd{plot.gtfs.block.shapes} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{highlight} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{...}\hlstd{) \{}
    \hlcom{# plot ALL of the shapes...}
    \hlstd{all} \hlkwb{<-} \hlkwd{do.call}\hlstd{(rbind, x)}

    \hlkwd{plot}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{type} \hlstd{=} \hlstr{"n"}\hlstd{,} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
         \hlkwc{xlim} \hlstd{=} \hlkwd{range}\hlstd{(all}\hlopt{$}\hlstd{lon),} \hlkwc{ylim} \hlstd{=} \hlkwd{range}\hlstd{(all}\hlopt{$}\hlstd{lat),}
         \hlkwc{xlab} \hlstd{=} \hlstr{"Longitude"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"Latitude"}\hlstd{,}
         \hlkwc{main} \hlstd{=} \hlkwd{paste}\hlstd{(}\hlstr{"Highlighting route"}\hlstd{, highlight))}

    \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(x)) \{}
        \hlkwa{if} \hlstd{(highlight[}\hlnum{1}\hlstd{]} \hlopt{==} \hlstd{i)}
            \hlkwd{plot}\hlstd{(x[[i]],} \hlkwc{add} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#ff000050"}\hlstd{,} \hlkwc{lwd} \hlstd{=} \hlnum{3}\hlstd{)}
        \hlkwa{else}
            \hlkwd{plot}\hlstd{(x[[i]],} \hlkwc{add} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{3}\hlstd{)}
    \hlstd{\}}
\hlstd{\}}

\hlstd{blockID} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(mbta,}
                        \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT block_id
                                 FROM trips WHERE trip_id='%s'"}\hlstd{, tID))}
\hlstd{bID} \hlkwb{<-} \hlstd{blockID}\hlopt{$}\hlstd{block_id}
\hlstd{block} \hlkwb{<-} \hlkwd{getBlock}\hlstd{(bID, mbta)}
\hlkwd{head}\hlstd{(block)}
\end{alltt}
\begin{verbatim}
##   block_id  trip_id route_id shape_id
## 1  S742-84 26206576      742  7420014
## 2  S742-84 26206570      742  7420014
## 3  S742-84 26206574      742  7420014
## 4  S742-84 26206578      742  7420014
## 5  S742-84 26206580      742  7420014
## 6  S742-84 26206582      742  7420014
\end{verbatim}
\begin{alltt}
\hlkwd{plot}\hlstd{(block)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-4-1} 

}



\end{knitrout}

We can see that a ``block'' consists of a lot of very similar routes (in this case, anyway).
So, instead of obtaining data for the same \emph{trip}, we could just grab a days worth of data for
a block, like this:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{getBlockData} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{date}\hlstd{,} \hlkwc{id}\hlstd{,} \hlkwc{conn}\hlstd{) \{}
    \hlstd{b} \hlkwb{<-} \hlkwd{getBlock}\hlstd{(id, conn)}
    \hlcom{#d <- lapply(b$trips$trip_id, function(ID) getTripData(date, ID, conn))}
    \hlstd{d} \hlkwb{<-} \hlkwd{dbGetQuery}\hlstd{(}
        \hlstd{conn,}
        \hlkwd{sprintf}\hlstd{(}\hlstr{"SELECT position_latitude AS lat, position_longitude AS lon,
                        timestamp AS time, trip_id
                 FROM vehicle_positions
                 WHERE trip_id IN (%s) AND trip_start_date='%s'
                 ORDER BY timestamp"}\hlstd{,}
                \hlkwd{paste0}\hlstd{(b}\hlopt{$}\hlstd{trips}\hlopt{$}\hlstd{trip_id,} \hlkwc{collapse} \hlstd{=} \hlstr{","}\hlstd{), date))}

    \hlkwd{class}\hlstd{(d)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"blockhistory"}\hlstd{,} \hlstr{"triphistory"}\hlstd{,} \hlkwd{class}\hlstd{(d))}
    \hlstd{d}
\hlstd{\}}
\hlstd{block.history} \hlkwb{<-} \hlkwd{getBlockData}\hlstd{(}\hlstr{"20151202"}\hlstd{, bID, mbta)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plot.pf.blockfit} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{obs} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{conn} \hlstd{= con) \{}
    \hlkwd{plot}\hlstd{(block)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{HXhat[}\hlnum{1}\hlstd{,,obs], x}\hlopt{$}\hlstd{HXhat[}\hlnum{2}\hlstd{,,obs],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00009930"}\hlstd{)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{HX[}\hlnum{1}\hlstd{,,obs], x}\hlopt{$}\hlstd{HX[}\hlnum{2}\hlstd{,,obs],} \hlkwc{pch} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"#00990070"}\hlstd{)}
    \hlkwd{points}\hlstd{(x}\hlopt{$}\hlstd{y[}\hlnum{1}\hlstd{,obs], x}\hlopt{$}\hlstd{y[}\hlnum{2}\hlstd{,obs],} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{pch} \hlstd{=} \hlnum{19}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.4}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The trouble here is that the model doesn't actually know where it is, and gets completely and
utterly lost, so we need some method for limiting where it can be---queue static timetable in GTFS.


\subsection{Static Schedule GTFS}





\end{document}
