\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage{parskip}
\usepackage{booktabs}


<<echo=FALSE,results="hide">>=
opts_knit$set(fig.width = 9, fig.height = 5, fig.align = "center")
suppressMessages({
    .libPaths("../../../.Rlibrary")
    library(RSQLite)
    library(msm)
    library(iNZightMaps)
    source("../src/R/database.R")
    source("../src/R/time_fns.R")
    source("../src/R/graphics.R")
    source("../src/R/particle_filter.R")
})
@ 

\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bY}{\boldsymbol{Y}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bd}{\boldsymbol{d}}
\newcommand{\bs}{\boldsymbol{s}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bfn}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bg}{\boldsymbol{g}}
\newcommand{\bH}{\boldsymbol{2H}}
\newcommand{\bK}{\boldsymbol{K}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bZero}{\boldsymbol{0}}
\newcommand{\dd}[2]{\frac{\partial {#1}}{\partial {#2}}}

\newcommand{\X}{\mathrm{X}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\V}{\mathrm{V}}


\newcommand{\pr}{\mathbb{P}}
\renewcommand{\Pr}[1]{\pr\left(#1\right)}


\newcommand{\km}{_{k-1}}
\newcommand{\kk}{_{k|k}}
\newcommand{\kkm}{_{k|k-1}}
\newcommand{\kmkm}{_{k-1|k-1}}


\title{Modelling Bus Route 090}
\author{}
\date{}

\begin{document}
\maketitle



\section{Initial Historical Data}
\label{sec:historical-data}


A couple of weeks worth of data was collected for the bus route 090 (Westgate to Downtown), 
and a very general Particle Filter model was used to estimate the distance into trip, $\bd$,
of each observation. 
This data is stored in the database \texttt{db/historical\_data.db}.
The following code extracts the raw history, 
and makes a few manipulations to make it easier to work with,
as well as remove some impossibly fast trips.

<<extract_historical_data,fig.height=5,fig.width=9>>=
routeid <- "09001-20151224100745_v36.10"
hist090 <- dbGetQuery(dbConnect(SQLite(), "historical-data.db"),
                      sprintf("SELECT * FROM history WHERE route_id='%s'",
                              routeid))
hist090$time.day <- hist090$timestamp - 
    as.numeric(format(as.POSIXct(paste(hist090$trip_start_date, 
                                       "00:00:00")), 
                      format = "%s"))
hist090$time.hour <- hist090$time.day / 60 / 60
hist090$dvt <- as.factor(paste(hist090$trip_start_date, 
                               hist090$trip_id, 
                               hist090$vehicle_id, 
                               sep = ":"))
which.keep <- 
    do.call(c,
            invisible(tapply(1:nrow(hist090), hist090$dvt, function(i) {
                d <- diff(range(hist090$time.day[i]))
                dt <- diff(hist090$time.day[i])
                dx <- diff(hist090$distance[i])
                if (max(dx/dt) < 50) return(i) else numeric()
            })))
hist090 <- hist090[which.keep, ]
with(hist090, plot(time.hour, distance, type = "n",
                   main = "History of Route 090", xlab = "Time (h)", 
                   ylab = "Distance into Trip (m)"))

invisible(tapply(1:nrow(hist090), hist090$dvt, 
                 function(i) lines(hist090$time.hour[i], hist090$distance[i])))
@ 


\section{Predicting a Route}
\label{sec:route_prediction}

From here, we will be using the historical data to project particles ahead to estimate arrival time at future stops.
There will be two parts to each iteration:
\begin{enumerate}
\item predict partical arrival times at future stops,
  
\item predict partical locations at time $t_{k-1} + \delta_k$.
\end{enumerate}
The first will be used to predict arrival time at stops, 
while the second will be used to predict the new location of the bus and produce a new set of particles for the next iteration.


Each bus reports its position at time $t_k$ as $r_k$ (latitude, longitude), 
where the $k$ subscript is the observation number.
The distance into trip at time $t_k$ is defined as $d_k$, 
and is known only as a distribution which is defined by the particles $\bw_k$.
For now, only distance will be used; in future, however, velocity may also be modelled.


The particles are updated using standard Particle Filter theory, 
so that after each new observation is obtained, 
the distribution of the particles represents the posterior distribution of $d_k$ via SIR.


For this example, we will use a single trip:
<<example_trip,fig.height=5,fig.width=9>>=
tripid <- "3090020609-20151224100745_v36.10"
hist <- hist090[hist090$trip_id == tripid, ]
hist$dvt <- factor(hist$dvt)
hist$time_into_trip <- 
    do.call(c, tapply(1:nrow(hist), hist$dvt, 
                      function(i) hist$time.day[i] - min(hist$time.day[i])))

test.trip <- hist[hist$trip_start_date == tail(unique(hist$trip_start_date), 1), ]
hist <- hist[hist$trip_start_date != tail(unique(hist$trip_start_date), 1), ]
hist$dvt <- factor(hist$dvt)

with(hist, plot(time_into_trip, distance, type = "n",
                main = "History of Route 090, 12:15 trip", 
                xlab = "Time into Trip (s)", 
                ylab = "Distance into Trip (m)"))
invisible(tapply(1:nrow(hist), hist$dvt, 
                 function(i) lines(hist$time_into_trip[i], hist$distance[i])))

stops <- 1:15 * 2000
abline(h = c(0, stops), col = "#0000ff", lty = 3)
@ 
The first model is going to ignore actual start time, and instead just use variability in travel times.
Also, to simplify, we have made up 15 evently spaced ``stops''.



\subsection{Arrival Times at Future Stops}
\label{sec:future_arrival_times}


The prediction of arrival times is actually fairly straight forward.
We start off with (for simplicity) 50 walkers, $w_0(i), i \in \{1,...,10\}$, 
all starting at zero.

<<initialise>>=
M <- 500
w <- rep(0, M)
@ 

From here, we wish to predict $a_1$, arrival time at stop number 1, $s_1$.
To do this, we need to know at what \emph{time} each historical journey arrives at the stop.
This is done by fitting a polynomial spline to each journey, 
and some fancy optimisation techniques to find $a_{1|\boldsymbol{j}}$ 
($\boldsymbol{j}$ represents all of the information associated with historical trip $j$).

<<spline_curves,fig.height=5,fig.width=9>>=
history.fn <- try({
    tapply(1:nrow(hist), hist$dvt, function(i) {
               f=splinefun(hist$time_into_trip[i],
                         hist$distance[i],
                         method = "hyman", ties = min)
               attr(f, "max") <- max(hist$time_into_trip[i])
               f
           })
}, silent = TRUE)
.arrivalTime <- function(d)
    sapply(history.fn, 
           function(f) optimize(function(x) (f(x) - d)^2,
                                interval = range(hist$time_into_trip))$minimum)
arrivalTime <- Vectorize(.arrivalTime, "d")
.history.fnD <- function(d, delta = 0, deriv = 0) {
    sapply(history.fn, function(f) {
               ## convert distance to time, time to ["speed", "acceleration"]
               t <- optimize(
                   function(x) (f(x) - d)^2,
                   interval = range(hist$time_into_trip)
                   )$minimum
               f(t + delta, deriv = deriv)
           })
}
history.fnD <- Vectorize(.history.fnD, "d")
draw <- function(s = 0, a, labs = TRUE, xlim = NULL, ylim = NULL) {
    with(hist, plot(time_into_trip, distance, type = "n",
                    main = ifelse(labs, "History of Route 090, 12:15 trip", ""), 
                    xlab = ifelse(labs, "Time into Trip (s)", ""),
                    ylab = ifelse(labs, "Distance into Trip (m)", ""),
                    xlim = xlim, ylim = ylim,
                    axes = labs))
    box()
    invisible(lapply(history.fn, function(f) 
        curve(f(x), 0, attr(f, "max"), n = 101, add = TRUE)))
    if (any(s == 0))
        abline(h = c(0, stops), col = "#0000ff", lty = 3)
    else if (all(s > 0))
        abline(h = stops[s], col = "#0000ff", lty = 3)
    
    if (!missing(a) && all(s > 0)) {
        if (!is.matrix(a)) a <- rbind(a)
        if (length(s) == nrow(a)) {
            for (i in 1:nrow(a))
                points(a[i, ], rep(stops[s[i]], ncol(a)), 
                       pch = 19, col = "red", cex = 0.3)
        }
    }
}
draw()
@ 


So, for the particles, the possible time of arrival at $s_1$ is:
<<stop_one_arrival,fig.width=9,fig.height=5>>=
a1j <- arrivalTime(stops[1])[,1]
a1 <- rtnorm(M, mean(a1j), sd(a1j), lower = 0)
draw(1, a = a1)
@ 

Without any data, all we can do is push on further into the future.
For stop 2 (and all future stops), we will use the historical time taken to travel between
stops 2 and 3 (or $s_k$ and $s_{k+1}$).

<<stops_remaining_arrival,fig.width=9,fig.height=5>>=
a <- matrix(nrow = 15, ncol = M)
a[1, ] <- a1
for (i in 2:15) {
    Delta <- arrivalTime(stops[i])[, 1] - arrivalTime(stops[i - 1])[, 1]
    a[i, ] <- a[i - 1, ] + rtnorm(M, mean(Delta), sd(Delta), lower = 0)
}
draw(s = 1:15, a = a)
@ 

We can also see the arrival distribution for stops, in a table:
<<results="asis">>=
tab <- t(apply(a, 1, function(x) c(mean(x), sd(x),
                                   quantile(x, c(0.025, 0.5, 0.975)))))
colnames(tab)[1:2] <- c("mean", "sd")

xtable::print.xtable(
    xtable::xtable(cbind(stop = as.character(1:nrow(tab)), 
                         round(tab / 60)), 
                   caption = "Sequential Predictions",
                   label = "tab:arrival_time_1"), 
    booktabs = TRUE, include.rownames = FALSE, floating = TRUE,
    table.placement = "p")
@ 


Now would be a good time to get one real trip, and see how well we do.
<<single_trip,fig.width=9,fig.height=5>>=
draw()
with(test.trip, lines(time_into_trip, distance, col = "red", lwd = 2))
@ 


Alternatively, we do the entire prediction (rather than just the stop-to-stop prediction):
<<alt_stop_prediction,fig.width=9,fig.height=5>>=
a <- matrix(nrow = 15, ncol = M)
a[1, ] <- a1
for (i in 2:15) {
    Delta <- arrivalTime(stops[i])[, 1]
    a[i, ] <- rtnorm(M, mean(Delta), sd(Delta), lower = 0)
}
draw(s = 1:15, a = a)
@ 

We can also see the arrival distribution for stops, in a table:
<<alt_results_table,results="asis">>=
tab <- t(apply(a, 1, function(x) c(mean(x), sd(x),
                                   quantile(x, c(0.025, 0.5, 0.975)))))
colnames(tab)[1:2] <- c("mean", "sd")

xtable::print.xtable(
    xtable::xtable(cbind(stop = as.character(1:nrow(tab)), 
                         round(tab / 60)), 
                   caption = "All-in-one Predictions",
                   label = "tab:arrival_time_1"), 
    booktabs = TRUE, include.rownames = FALSE, floating = TRUE,
    table.placement = "p")
@ 

Using this all-in-one method, the variance might be slightly smaller,
but otherwise fairly similar.




\subsection{Particle Position Update}
\label{sec:particle_likelihood}

From the above plot, we get sequential real-time updates from the bus as it travels.
Therefore, we wish to update the predictions in Table~\ref{tab:arrival_time_1} as new data arrives.
To do this, we need to use the \emph{current state} of each particle 
$\bx_k(i) = \left[d_k(i), v_k(i)\right]^T$
to predict the \emph{new state} after $\delta_{k+1}$ seconds.


For starters, we'll just go really basic and use the distribution of distance traveled in $\delta_{k+1}$ seconds.
NOTE: we'll just assume for now that the first observation was made before the bus departed
the first stop, so the first row is all 0.
<<first_observation,fig.width=9,fig.height=5>>=
## convert w from before into a matrix
N <- nrow(test.trip)
w <- matrix(nrow = N, ncol = length(w))
w[1, ] <- 0
w0 <- w  ## matrix for the original estimates

t <- test.trip$time_into_trip
delta.t <- c(0, diff(t))

pred <- history.fnD(w[1, ], delta.t[2])
w0[2, ] <- rtnorm(ncol(w), colMeans(pred), apply(pred, 2, sd), lower = w[1, ])
pi <- dnorm(w0[2, ], test.trip$distance[2], 20)
wi <- pi / sum(pi)
w[2, ] <- sample(w0[2, ], M, TRUE, wi)
draw(1, a = a[2, ], xlim = c(0, 1000), ylim = c(0, 5200))
points(rep(t[2], M), w0[2, ], col = "#009900", pch = 19, cex = 0.3)
points(rep(t[2], M), w[2, ], col = "#000099", pch = 19, cex = 0.3)
@ 


Next step, repeat! Update the stop arrival time predictions.

<<arrival_times_2,fig.width=9,fig.height=5>>=
a <- matrix(nrow = 15, ncol = M)

ti <- test.trip$time_into_trip[2]
a1j <- arrivalTime(stops[1])[,1] - ti
a1 <- ti + rtnorm(M, mean(a1j), sd(a1j), lower = ti)
draw(1, a = a1)

a[1, ] <- a1
for (i in 2:15) {
    Delta <- arrivalTime(stops[i])[, 1] - ti
    a[i, ] <- ti + rtnorm(M, mean(Delta), sd(Delta)/sqrt(length(Delta)), lower = ti)
}
draw(1:15, a)
points(rep(t[2], M), w0[2, ], col = "#009900", pch = 19, cex = 0.3)
points(rep(t[2], M), w[2, ], col = "#000099", pch = 19, cex = 0.3)
@


<<results="asis">>=
tab <- t(apply(a, 1, function(x) c(mean(x), sd(x),
                                   quantile(x, c(0.025, 0.5, 0.975)))))
colnames(tab)[1:2] <- c("mean", "sd")

xtable::print.xtable(
    xtable::xtable(cbind(stop = as.character(1:nrow(tab)), 
                         round((tab - ti) / 60)), 
                   caption = "Predictions after one observation",
                   label = "tab:arrival_time_1"), 
    booktabs = TRUE, include.rownames = FALSE, floating = TRUE,
    table.placement = "tb")
@ 


Another step:
<<second_observation,fig.width=9,fig.height=5>>=
predict <- function(i, draw = TRUE, ...) {
    pred <- history.fnD(w[i - 1, ], delta.t[i])
    w0[i, ] <<- rtnorm(ncol(w), colMeans(pred), apply(pred, 2, sd), lower = w[i - 1, ])
    pi <- dnorm(w0[i, ], test.trip$distance[i], 20)
    wi <- pi / sum(pi)
    w[i, ] <<- sample(w0[i, ], M, TRUE, wi)
    
    wstops <- which(stops > min(w[i, ]))
    stops <- stops[wstops]
    
    a <- matrix(nrow = length(stops), ncol = M)    
    ti <- test.trip$time_into_trip[i]
    a1j <- arrivalTime(stops[1])[,1] - ti
    a1 <- ti + rtnorm(M, mean(a1j), sd(a1j) / sqrt(length(Delta)), lower = 0)
    
    a[1, ] <- a1
    for (j in 2:length(stops)) {
        Delta <- arrivalTime(stops[j])[, 1] - ti
        a[j, ] <- ti + rtnorm(M, mean(Delta), sd(Delta)/sqrt(length(Delta)), lower = 0)
    }
    if (draw) {
        draw(wstops, a, ...)
        points(rep(t[i], M), w0[i, ], col = "#009900", pch = 19, cex = 0.3)
        points(rep(t[i], M), w[i, ], col = "#000099", pch = 19, cex = 0.3)
    }
}
predict(3)
@ 

Well, that seems to be working! Let's take off!
<<future_observations,fig.width=9,fig.height=12>>=
par(mfcol = c(6, 2), mar = c(0, 0, 0, 1), oma = c(5.1, 4.1, 4.1, 2.1))
for (i in 4:27) 
    predict(i, labs = FALSE)
@ 


Continue on for the entire route, and then check the results!
<<remaining_obs>>=
for(i in 28:nrow(test.trip)) predict(i, draw = FALSE)
@ 



\end{document}
